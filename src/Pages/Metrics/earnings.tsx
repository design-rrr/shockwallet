import { useEffect, useState } from "react"
import Dropdown, { Period, periodOptionsArray, getPeriodText } from "../../Components/Dropdowns/LVDropdown"
import { AdminGuard, AdminSource } from "../../Components/AdminGuard"
import { getNostrClient } from "../../Api"
import { toast } from "react-toastify";
import * as Icons from "../../Assets/SvgIconLibrary";
import styles from "./styles/index.module.scss";
import classNames from 'classnames';
import * as Types from '../../Api/pub/autogenerated/ts/types';
import { IonButton, IonCard, IonCardContent, IonCardHeader, IonCardTitle, IonContent, IonLabel, IonItem, IonList, IonListHeader, IonIcon, IonItemDivider } from "@ionic/react";
import { flashOutline, linkOutline, personOutline, radioOutline } from "ionicons/icons";

export default function Earnings() {
    const [period, setPeriod] = useState<Period>(Period.WEEK)
    const [offset, setOffset] = useState<number>(0)
    const [adminSource, setAdminSource] = useState<AdminSource | null>(null)
    const [metrics, setMetrics] = useState<Types.AppsMetrics>()
    const [fwMetrics, setFwMetrics] = useState<Types.LndForwardingMetrics>()
    const [totalOut, setTotalOut] = useState<number>(0)
    const [showingOps, setShowingOps] = useState("")
    useEffect(() => {
        const params = new URLSearchParams(window.location.search)
        const period = params.get("period")
        const offset = params.get("offset")
        if (period) {
            setPeriod(period as Period)
        }
        if (offset) {
            setOffset(parseInt(offset))
        }
    }, [])
    useEffect(() => {
        fetchMetrics()
    }, [period, offset, adminSource])
    const nextOffset = () => {
        if (period === Period.ALL_TIME || offset >= 0) {
            return
        }
        setOffset(offset + 1)
    }

    const prevOffset = () => {
        if (period === Period.ALL_TIME) {
            return
        }
        setOffset(offset - 1)
    }
    const fetchMetrics = async () => {
        if (!adminSource) {
            return
        }
        const client = await getNostrClient(adminSource.nprofile, adminSource.keys)
        const periodRange = getUnixTimeRange(period, offset);
        const [metrics, lndFwMetrics] = await Promise.all([
            client.GetAppsMetrics({ ...periodRange, include_operations: true }),
            client.GetLndForwardingMetrics({ ...periodRange })
        ])
        if (metrics.status !== 'OK') {
            toast.error(metrics.reason)
        } else {
            console.log({ metrics })
            setMetrics(metrics)
        }

        if (lndFwMetrics.status !== 'OK') {
            toast.error(lndFwMetrics.reason)
        } else {
            console.log({ lndFwMetrics })
            setFwMetrics(lndFwMetrics)
            let totOut = 0
            lndFwMetrics.events.forEach(fw => {
                totOut += fw.amt_out
            })
            setTotalOut(totOut)
        }
    }
    if (!adminSource) {
        return <AdminGuard updateSource={s => { console.log({ adminSource }); setAdminSource(s) }} />
    }
    return <div className={styles["metrics-container"]}>
        <div className={styles["section"]}>
            <div className={styles["center"]}>
                <Dropdown<Period>
                    setState={(value) => { setPeriod(value); setOffset(0) }}
                    otherOptions={periodOptionsArray}
                    jsx={<div className={classNames(styles["center"], styles["box"])}>
                        <span className={styles["icon_pub"]}>{Icons.Automation()}</span>
                        <span>{getPeriodText(period, offset)}</span>
                    </div>}
                />
                <div style={{ display: 'flex', alignItems: 'center', }} className={styles["box"]}>
                    <div onClick={() => prevOffset()} >{Icons.arrowLeft()}</div>
                    {Icons.verticalLine()}
                    <div onClick={() => nextOffset()} >{Icons.arrowRight()}</div>
                </div>
            </div>
        </div>
        <IonCard style={{ width: '100%', marginTop: 10 }} color="secondary">
            <IonCardHeader>Lnd Forwarding</IonCardHeader>
            {(!fwMetrics || fwMetrics.events.length === 0) && <IonCardContent>
                <div>No operations</div>
            </IonCardContent>}
            {fwMetrics && fwMetrics.events.length > 0 && <IonCardContent>
                <div>Moved {totalOut} sats in {fwMetrics?.events.length} htlcs</div>
                <div>Earned {fwMetrics?.total_fees} sats</div>
                {showingOps !== '__lnd' && <IonButton onClick={() => setShowingOps("__lnd")}>Show Htlcs</IonButton>}
                {showingOps === '__lnd' && <IonButton onClick={() => setShowingOps("")}>Hide Htlcs</IonButton>}
                {showingOps === '__lnd' && <IonList>
                    <IonListHeader>
                        <IonLabel>Sats In</IonLabel>
                        <IonLabel>Sats Out</IonLabel>
                        <IonLabel>Fees</IonLabel>
                    </IonListHeader>
                    {fwMetrics.events.map((fw, i) => <IonItem key={i}>
                        <IonLabel>{fw.amt_in}</IonLabel>
                        <IonLabel>{fw.amt_out}</IonLabel>
                        <IonLabel>{fw.fee}</IonLabel>
                    </IonItem>)}
                </IonList>}
            </IonCardContent>}
        </IonCard>
        <IonItemDivider />
        {metrics?.apps.map((app, i) => <IonCard key={i} style={{ width: '100%', marginTop: 10 }} color="secondary" >
            <IonCardHeader>
                <IonCardTitle>{app.app.name}</IonCardTitle>
            </IonCardHeader>
            {app.operations.length > 0 && <IonCardContent>
                <div>Moved {app.received + app.spent} sats in {app.operations.length} operations</div>
                <div>Earned {app.fees} sats</div>
                {showingOps !== app.app.name && <IonButton onClick={() => setShowingOps(app.app.name)}>Show operations</IonButton>}
                {showingOps === app.app.name && <IonButton onClick={() => setShowingOps("")}>Hide operations</IonButton>}
                {showingOps === app.app.name && <IonList>
                    <IonListHeader>
                        <IonLabel>Op type</IonLabel>
                        <IonLabel>Amount</IonLabel>
                        <IonLabel>Service fee</IonLabel>
                    </IonListHeader>
                    {app.operations.map((op, i) => <IonItem key={i}>
                        <IonLabel><IonIcon icon={iconType(op.type)} style={{ color: iconColor(op.type) }} /></IonLabel>
                        <IonLabel>{op.amount}</IonLabel>
                        <IonLabel>{op.service_fee}</IonLabel>
                    </IonItem>)}
                </IonList>}
            </IonCardContent>}
            {app.operations.length === 0 && <IonCardContent>
                <div>No operations</div>
            </IonCardContent>}
        </IonCard>)}
    </div>
}

export const getUnixTimeRange = (period: Period, offset: number) => {
    const now = new Date();
    let from_unix: number, to_unix: number;

    switch (period) {
        case Period.WEEK: {
            /*       const thisWeek = new Date(now.setDate(now.getDate() - now.getDay()))
                  thisWeek.setHours(0, 0, 0, 0)
                  console.log({ thisWeek: thisWeek.toISOString() })
                  const thisWeekMs = thisWeek.getTime() */

            const firstDayOfWeek = new Date(new Date().setDate(now.getDate() - now.getDay() + (offset * 7))).setHours(0, 0, 0, 0);
            const lastDayOfWeek = new Date(new Date().setDate(now.getDate() - now.getDay() + 6 + (offset * 7))).setHours(23, 59, 59, 999);
            from_unix = Math.floor(firstDayOfWeek / 1000);
            to_unix = Math.floor(lastDayOfWeek / 1000);
            break;
        }

        case Period.MONTH: {
            const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth() + offset, 1).getTime();
            const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1 + offset, 0).setHours(23, 59, 59, 999);
            from_unix = Math.floor(firstDayOfMonth / 1000);
            to_unix = Math.floor(lastDayOfMonth / 1000);
            break;
        }

        case Period.YEAR: {
            const firstDayOfYear = new Date(now.getFullYear() + offset, 0, 1).getTime();
            const lastDayOfYear = new Date(now.getFullYear() + offset, 11, 31).setHours(23, 59, 59, 999);
            from_unix = Math.floor(firstDayOfYear / 1000);
            to_unix = Math.floor(lastDayOfYear / 1000);
            break;
        }
        case Period.ALL_TIME:
            return undefined
    }
    console.log({ from_unix: new Date(from_unix * 1000).toISOString(), to_unix: new Date(to_unix * 1000).toISOString() })
    return { from_unix, to_unix };
}

const iconType = (t: Types.UserOperationType) => {
    switch (t) {
        case Types.UserOperationType.INCOMING_INVOICE:
        case Types.UserOperationType.OUTGOING_INVOICE:
            return flashOutline
        case Types.UserOperationType.INCOMING_USER_TO_USER:
        case Types.UserOperationType.OUTGOING_USER_TO_USER:
            return personOutline
        case Types.UserOperationType.INCOMING_TX:
        case Types.UserOperationType.OUTGOING_TX:
            return linkOutline
    }
}

const iconColor = (t: Types.UserOperationType) => {
    switch (t) {
        case Types.UserOperationType.INCOMING_INVOICE:
        case Types.UserOperationType.INCOMING_USER_TO_USER:
        case Types.UserOperationType.INCOMING_TX:
            return 'green'
        case Types.UserOperationType.OUTGOING_INVOICE:
        case Types.UserOperationType.OUTGOING_USER_TO_USER:
        case Types.UserOperationType.OUTGOING_TX:
            return 'red'
        default:
            return 'white'
    }
}