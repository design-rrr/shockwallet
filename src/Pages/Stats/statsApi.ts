import { Buffer } from 'buffer';
import { getNostrClient } from "../../Api/nostr"
import { SpendFrom } from "../../globalTypes"
import { parseTLV, tlvToUsageMetrics } from "./tlv"
import * as Types from '../../Api/pub/autogenerated/ts/types'
import { bytesToHex } from '@noble/hashes/utils';
import { AdminSource } from '../../Components/AdminGuard';
export type MetricsDataEntry<T> = { entries: T[], currentPage: number, allPages: number[] }
export type MetricsData<T> = Record<string, Record<string, MetricsDataEntry<T>>>
export type BundleDataPoint = { unix: number, v: number }
export const fetchErrors = async (source: AdminSource) => {
    const c = await getNostrClient(source.nprofile, source.keys)
    const errors = await c.GetErrorStats()
    if (errors.status !== 'OK') {
        throw new Error('Error fetching error stats ' + errors.reason)
    }
    return { errors }
}


export const fetchBundleStats = async (source: AdminSource) => {
    const c = await getNostrClient(source.nprofile, source.keys)
    const res = await c.GetBundleMetrics({})
    if (res.status !== 'OK') {
        throw new Error('Error fetching bundle stats ' + res.reason)
    }
    const apps = Object.keys(res.apps)
    const bundleData = {} as MetricsData<BundleDataPoint>
    apps.forEach(app => {
        const appBundles = res.apps[app].app_bundles
        console.log(appBundles)
        bundleData[app] = {}
        Object.keys(appBundles).forEach(bundleId => {
            const bundle = appBundles[bundleId]
            bundleData[app][bundleId] = {
                entries: bundle.base_64_data.map(dataString => {
                    const decoded = Uint8Array.from(Buffer.from(dataString, 'base64'))
                    const ts = decoded.slice(0, 4)
                    const unix = parseInt(bytesToHex(ts), 16)
                    const val = decoded.slice(4, 8)
                    const v = parseInt(bytesToHex(val), 16)
                    return { unix, v }
                }),
                allPages: bundle.available_chunks,
                currentPage: bundle.current_chunk
            }
        })
    })
    return { bundleData, apps }
}

export const fetchUsageStats = async (source: AdminSource) => {
    const c = await getNostrClient(source.nprofile, source.keys)
    const res = await c.GetUsageMetrics({})
    if (res.status !== 'OK') {
        throw new Error('Error fetching usage metrics ' + res.reason)
    }
    const apps = Object.keys(res.apps)
    const usageData = {} as MetricsData<Types.UsageMetric>
    apps.forEach((app) => {
        const appMetrics = res.apps[app].app_metrics
        console.log(appMetrics)
        usageData[app] = {}
        Object.keys(appMetrics).forEach((rpcMethod) => {
            const methodMetrics = appMetrics[rpcMethod].base_64_tlvs.map(tlvString => {
                const decoded = Uint8Array.from(Buffer.from(tlvString, 'base64'))
                const tlv = parseTLV(decoded)
                const metric = tlvToUsageMetrics("", tlv)
                return metric
            })
            usageData[app][rpcMethod] = { entries: methodMetrics, allPages: appMetrics[rpcMethod].available_chunks, currentPage: appMetrics[rpcMethod].current_chunk }
        })
    })
    return { usageData, apps }
}

/*     const minTime = new Date(min)
      const from = `${minTime.getFullYear()}-${z(minTime.getMonth() + 1)}-${z(minTime.getDate())} ${z(minTime.getHours())}:${z(minTime.getMinutes())}:${z(minTime.getSeconds())}`
      const maxTime = new Date(max)
      const to = `${maxTime.getFullYear()}-${z(maxTime.getMonth() + 1)}-${z(maxTime.getDate())} ${z(maxTime.getHours())}:${z(maxTime.getMinutes())}:${z(maxTime.getSeconds())}` */