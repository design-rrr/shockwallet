import { toast } from "react-toastify";
import { Buffer } from 'buffer';
import moment from "moment";
import { Chart as ChartJS, registerables, Legend } from 'chart.js';
import { Chart, Line } from 'react-chartjs-2'
ChartJS.register(...registerables, Legend);
import * as Icons from "../../Assets/SvgIconLibrary";
import { Clipboard } from "@capacitor/clipboard";
import React, { useEffect, useMemo, useState } from "react";
import BootstrapSource from "../../Assets/Images/bootstrap_source.jpg";
import { useSelector, useDispatch, selectEnabledSpends, selectConnectedNostrSpends } from '../../State/store';
import { PayTo, SpendFrom } from "../../globalTypes";
import { getNostrClient } from "../../Api";
import { useParams, useLocation } from "react-router";
import * as Types from '../../Api/pub/autogenerated/ts/types'
import Checkbox from "../../Components/Checkbox";
import { parseTLV, tlvToUsageMetrics } from "./tlv";
type OfferItemType = {
  title: string;
  value: string;
  type: string;
};
type UsageData = Record<string, Record<string, Types.UsageMetric[]>>
type SelectedMetrics = {
  auth_in_nano?: boolean
  handle_in_nano?: boolean
  parsed_in_nano?: boolean
  validate_in_nano?: boolean
}
const z = (n: number) => n < 10 ? `0${n}` : `${n}`
export const Stats = () => {
  const [apps, setApps] = useState<string[]>([])
  const [data, setData] = useState<UsageData>()
  const [range, setRange] = useState<{ from: string, to: string }>()
  const [selectedApp, setSelectedApp] = useState<string>('')
  const [selectedSource, setSelectedSource] = useState<string>('')
  const [selectedMetrics, setSelectedMetrics] = useState<SelectedMetrics>({ handle_in_nano: true })
  const [successFilter, setSuccessFilter] = useState<'yes' | 'no' | ''>("")
  const [nostrFilter, setNostrFilter] = useState<'yes' | 'no' | ''>("")
  const [errorStats, setErrorStats] = useState<Types.ErrorStats>()
  const enabledPaySources = useSelector((state) =>
    state.spendSource.order.map(id => state.spendSource.sources[id]).filter(source => source.pubSource && source.adminToken))
  const fetchStats = async (source: SpendFrom) => {
    const c = await getNostrClient(source.pasteField, source.keys)
    const errors = await c.GetErrorStats()
    if (errors.status !== 'OK') {
      toast.error('Error fetching error stats ' + errors.reason)
      return
    }
    console.log(errors)
    setErrorStats(errors)
    const res = await c.GetUsageMetrics()
    if (res.status !== 'OK') {
      toast.error('Error fetching metrics ' + res.reason)
      return
    }
    console.log({ appMetrics: res })
    const apps = Object.keys(res.apps)
    console.log(apps)
    const usageData = {} as UsageData
    let min = Number.MAX_SAFE_INTEGER
    let max = 0
    apps.forEach((app) => {
      const appMetrics = res.apps[app].app_metrics
      console.log(appMetrics)
      usageData[app] = {}
      Object.keys(appMetrics).forEach((rpcMethod) => {
        const methodMetrics = appMetrics[rpcMethod].base_64_tlvs.map(tlvString => {
          const decoded = Uint8Array.from(Buffer.from(tlvString, 'base64'))
          const tlv = parseTLV(decoded)
          const metric = tlvToUsageMetrics("", tlv)
          if (metric.processed_at_ms < min) min = metric.processed_at_ms
          if (metric.processed_at_ms > max) max = metric.processed_at_ms
          return metric
        })
        usageData[app][rpcMethod] = methodMetrics
      })
    })
    setData(usageData)
    setApps(apps)
    const minTime = new Date(min)
    const from = `${minTime.getFullYear()}-${z(minTime.getMonth() + 1)}-${z(minTime.getDate())} ${z(minTime.getHours())}:${z(minTime.getMinutes())}:${z(minTime.getSeconds())}`
    const maxTime = new Date(max)
    const to = `${maxTime.getFullYear()}-${z(maxTime.getMonth() + 1)}-${z(maxTime.getDate())} ${z(maxTime.getHours())}:${z(maxTime.getMinutes())}:${z(maxTime.getSeconds())}`
    setRange({ from, to })
    console.log(usageData)
  }
  useEffect(() => {
    if (!selectedSource) return
    const source = enabledPaySources.find((source) => source.pasteField === selectedSource)
    if (!source) return
    fetchStats(source)
  }, [selectedSource])

  const rows = useMemo(() => {
    if (!data || !data[selectedApp]) return []
    //const toRender = [] as JSX.Element[]
    //let max = 0
    //let min = Number.MAX_SAFE_INTEGER
    return Object.keys(data[selectedApp]).map((rpcMethod) => {
      const methodMetrics = data[selectedApp][rpcMethod]
      const labels = [] as string[]
      const handleInNanoData = [] as number[]
      const authInNanoData = [] as number[]
      const parsedInNanoData = [] as number[]
      const validateInNanoData = [] as number[]

      const graphData = [] as number[]
      methodMetrics.forEach(metric => {
        if (successFilter === 'yes' && !metric.success) return
        if (successFilter === 'no' && metric.success) return
        if (nostrFilter === 'yes' && !metric.nostr) return
        if (nostrFilter === 'no' && metric.nostr) return
        const d = new Date(metric.processed_at_ms)
        const date = `${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}`
        labels.push(date)
        if (selectedMetrics.auth_in_nano) authInNanoData.push(metric.auth_in_nano / 1000000)
        if (selectedMetrics.handle_in_nano) handleInNanoData.push(metric.handle_in_nano / 1000000)
        if (selectedMetrics.parsed_in_nano) parsedInNanoData.push(metric.parsed_in_nano / 1000000)
        if (selectedMetrics.validate_in_nano) validateInNanoData.push(metric.validate_in_nano / 1000000)
      })
      const datas = [
        { label: "Auth time (ms)", data: authInNanoData, color: '#66c2a5' },
        { label: "Handle time (ms)", data: handleInNanoData, color: '#fee08b' },
        { label: "Parsed time (ms)", data: parsedInNanoData, color: '#5e4fa2' },
        { label: "Validate time (ms)", data: validateInNanoData, color: '#9e0142' },]
      const datasets = datas.filter(({ data }) => data.length > 0).map((d, i) => ({
        label: d.label,
        data: d.data,
        backgroundColor: d.color,
        borderColor: d.color,
        color: d.color,
        //fill: true,
        //color: randomHexColors[randomHexColors.length % i],
        //tension: 0.1,
      }))
      return <div key={rpcMethod} style={{ width: 600, border: '1px solid black' }}>
        <h2>{rpcMethod}</h2>
        <Line data={{
          labels,
          datasets,
        }} />
      </div>
    })
  }, [selectedSource, selectedApp, selectedMetrics, successFilter, nostrFilter])

  return <div>
    <h1>Stats</h1>
    {range && <>
      <p>From {range.from}</p>
      <p>To {range.to}</p>
    </>}
    {errorStats && <>
      <p>Percent of Errors in the last 24h {errorStats.past24h.total > 0 ? Math.ceil(100 * errorStats.past24h.errors / errorStats.past24h.total) : 0}%</p>
      <p>Percent of Errors in the last 6h {errorStats.past6h.total > 0 ? Math.ceil(100 * errorStats.past6h.errors / errorStats.past6h.total) : 0}%</p>
      <p>Percent of Errors in the last 1h {errorStats.past1h.total > 0 ? Math.ceil(100 * errorStats.past1h.errors / errorStats.past1h.total) : 0}%</p>
      <p>Percent of Errors in the last 10m {errorStats.past10m.total > 0 ? Math.ceil(100 * errorStats.past10m.errors / errorStats.past10m.total) : 0}%</p>
      <p>Percent of Errors in the last 1m {errorStats.past1m.total > 0 ? Math.ceil(100 * errorStats.past1m.errors / errorStats.past1m.total) : 0}%</p>
    </>}
    <select style={{ color: "black" }} value={selectedSource} onChange={(e) => setSelectedSource(e.target.value)}>
      <option value="" hidden>Select Source</option>
      {enabledPaySources.map((item, index) => <option key={index} value={item.pasteField}>{item.label}</option>)}
    </select>
    <br />
    <select style={{ color: "black" }} value={selectedApp} onChange={(e) => setSelectedApp(e.target.value)}>
      <option value="" hidden>Select App</option>
      {apps.map((app, index) => <option key={index} value={app}>{app}</option>)}
    </select>
    <br />
    {selectedApp && selectedSource && <>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="auth_in_nano" state={!!selectedMetrics.auth_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, auth_in_nano: e.target.checked })} />
        <label>Auth In (ms)</label>
      </div>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="handle_in_nano" state={!!selectedMetrics.handle_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, handle_in_nano: e.target.checked })} />
        <label>Handle In (ms)</label>
      </div>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="parsed_in_nano" state={!!selectedMetrics.parsed_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, parsed_in_nano: e.target.checked })} />
        <label>Parsed In (ms)</label>
      </div>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="validate_in_nano" state={!!selectedMetrics.validate_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, validate_in_nano: e.target.checked })} />
        <label>Validate In (ms)</label>
      </div>
      <select style={{ color: "black" }} value={successFilter} onChange={(e) => setSuccessFilter(e.target.value as 'yes' | 'no' | '')}>
        <option value="">Success Or Failure</option>
        <option value="yes">Success</option>
        <option value="no">Failure</option>
      </select>
      <br />
      <select style={{ color: "black" }} value={nostrFilter} onChange={(e) => setNostrFilter(e.target.value as 'yes' | 'no' | '')}>
        <option value="">Nostr Or Http</option>
        <option value="yes">Nostr</option>
        <option value="no">Http</option>
      </select>
    </>}
    <div style={{ display: 'flex', flexWrap: 'wrap' }} >{rows}</div>
  </div>
}
