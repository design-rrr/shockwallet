import { toast } from "react-toastify";
import { Buffer } from 'buffer';
import moment from "moment";
import { Chart as ChartJS, registerables, Legend } from 'chart.js';
import { Chart, Line } from 'react-chartjs-2'
ChartJS.register(...registerables, Legend);
import * as Icons from "../../Assets/SvgIconLibrary";
import { Clipboard } from "@capacitor/clipboard";
import React, { useEffect, useMemo, useState } from "react";
import BootstrapSource from "../../Assets/Images/bootstrap_source.jpg";
import { useSelector, useDispatch, selectEnabledSpends, selectConnectedNostrSpends } from '../../State/store';
import { PayTo, SpendFrom } from "../../globalTypes";
import { getNostrClient } from "../../Api";
import { useParams, useLocation } from "react-router";
import * as Types from '../../Api/pub/autogenerated/ts/types'
import Checkbox from "../../Components/Checkbox";
import { parseTLV, tlvToUsageMetrics } from "./tlv";
import { MetricsData, SelectedMetrics, StatsGraph, z } from "./StatsGraph";
import { newWebRtcConnection } from "./webRTC";
//import { MetricsData } from "./StatsGraph";
type OfferItemType = {
  title: string;
  value: string;
  type: string;
};
//const z = (n: number) => n < 10 ? `0${n}` : `${n}`
//export type MetricsData = { entries: Types.UsageMetric[], currentPage: number, allPages: number[] }
type UsageData = Record<string, Record<string, MetricsData>>
type PagedData = Record<string, Record<string, Record<number, Types.UsageMetric[]>>>
/* type SelectedMetrics = {
  auth_in_nano?: boolean
  handle_in_nano?: boolean
  parsed_in_nano?: boolean
  validate_in_nano?: boolean
} */

export const Stats = () => {
  const [apps, setApps] = useState<string[]>([])
  const [data, setData] = useState<UsageData>()
  const [sendWrtcReq, setSendWrtcReq] = useState<{ f: (m: Types.SingleUsageMetricReq) => Promise<Uint8Array> }>()
  //const [moreData, setMoreData] = useState<PagedData>()
  const [range, setRange] = useState<{ from: string, to: string }>()
  const [selectedApp, setSelectedApp] = useState<string>('')
  const [selectedSourceId, setSelectedSourceId] = useState<string>('')
  const [selectedSource, setSelectedSource] = useState<SpendFrom>()
  const [selectedMetrics, setSelectedMetrics] = useState<SelectedMetrics>({ handle_in_nano: true })
  const [successFilter, setSuccessFilter] = useState<'yes' | 'no' | ''>("")
  const [nostrFilter, setNostrFilter] = useState<'yes' | 'no' | ''>("")
  const [errorStats, setErrorStats] = useState<Types.ErrorStats>()
  const enabledPaySources = useSelector((state) =>
    state.spendSource.order.map(id => state.spendSource.sources[id]).filter(source => source.pubSource && source.adminToken))
  const fetchStats = async (source: SpendFrom) => {
    const c = await getNostrClient(source.pasteField, source.keys)
    const errors = await c.GetErrorStats()
    if (errors.status !== 'OK') {
      toast.error('Error fetching error stats ' + errors.reason)
      return
    }
    console.log(errors)
    setErrorStats(errors)
    const res = await c.GetUsageMetrics({})
    if (res.status !== 'OK') {
      toast.error('Error fetching metrics ' + res.reason)
      return
    }
    console.log({ appMetrics: res })
    const apps = Object.keys(res.apps)
    console.log(apps)
    const usageData = {} as UsageData
    //const moreDataInit = {} as PagedData
    let min = Number.MAX_SAFE_INTEGER
    let max = 0
    apps.forEach((app) => {
      const appMetrics = res.apps[app].app_metrics
      console.log(appMetrics)
      usageData[app] = {}
      //moreDataInit[app] = {}
      Object.keys(appMetrics).forEach((rpcMethod) => {
        const methodMetrics = appMetrics[rpcMethod].base_64_tlvs.map(tlvString => {
          const decoded = Uint8Array.from(Buffer.from(tlvString, 'base64'))
          const tlv = parseTLV(decoded)
          const metric = tlvToUsageMetrics("", tlv)
          if (metric.processed_at_ms < min) min = metric.processed_at_ms
          if (metric.processed_at_ms > max) max = metric.processed_at_ms
          return metric
        })
        usageData[app][rpcMethod] = { entries: methodMetrics, allPages: appMetrics[rpcMethod].available_chunks, currentPage: appMetrics[rpcMethod].current_chunk }
        //moreDataInit[app][rpcMethod] = {}
      })
    })
    setData(usageData)
    //setMoreData(moreDataInit)
    setApps(apps)
    const minTime = new Date(min)
    const from = `${minTime.getFullYear()}-${z(minTime.getMonth() + 1)}-${z(minTime.getDate())} ${z(minTime.getHours())}:${z(minTime.getMinutes())}:${z(minTime.getSeconds())}`
    const maxTime = new Date(max)
    const to = `${maxTime.getFullYear()}-${z(maxTime.getMonth() + 1)}-${z(maxTime.getDate())} ${z(maxTime.getHours())}:${z(maxTime.getMinutes())}:${z(maxTime.getSeconds())}`
    setRange({ from, to })
    console.log(usageData)
  }

  useEffect(() => {
    if (!selectedSource) return
    newWebRtcConnection(selectedSource, (sendFunc) => {
      console.log("wrtc is ready")
      setSendWrtcReq({ f: sendFunc })
    })
  }, [selectedSource])

  useEffect(() => {
    if (!selectedSourceId) return
    const source = enabledPaySources.find((source) => source.pasteField === selectedSourceId)
    if (!source) return
    setSelectedSource(source)
    fetchStats(source)
  }, [selectedSourceId])

  /*   const loadMore = async (app: string, rpcMethod: string, page: number) => {
      if (!selectedSourceId || !moreData || moreData[app][rpcMethod] === undefined) {
        toast.error('Something went wrong')
        return
      }
      const source = enabledPaySources.find((source) => source.pasteField === selectedSourceId)
      if (!source) return
      const c = await getNostrClient(source.pasteField, source.keys)
      const res = await c.GetSingleUsageMetrics({ app_id: app, metrics_name: rpcMethod, page })
      if (res.status !== 'OK') {
        toast.error('Error fetching metrics ' + res.reason)
        return
      }
      moreData[app][rpcMethod][page] = res.base_64_tlvs.map(tlvString => {
        const decoded = Uint8Array.from(Buffer.from(tlvString, 'base64'))
        const tlv = parseTLV(decoded)
        return tlvToUsageMetrics("", tlv)
      })
      console.log(moreData)
      setMoreData({ ...moreData })
    } */

  const rows = useMemo(() => {
    if (!data || !data[selectedApp]) return []
    return Object.keys(data[selectedApp]).map((rpcMethod) => {
      const methodMetrics = data[selectedApp][rpcMethod]
      return <StatsGraph key={rpcMethod} fetchPage={(page) => {
        if (!sendWrtcReq) {
          throw new Error('No wrtc connection')
        }
        console.log("fetching...")
        return sendWrtcReq.f({ app_id: selectedApp, metrics_name: rpcMethod, page })
      }} rpcMethod={rpcMethod}
        methodMetrics={methodMetrics} nostrFilter={nostrFilter} successFilter={successFilter} selectedMetrics={selectedMetrics} />
    })
  }, [selectedSourceId, selectedApp, selectedMetrics, successFilter, nostrFilter])

  return <div>
    <h1>Stats</h1>
    {range && <>
      <p>From {range.from}</p>
      <p>To {range.to}</p>
    </>}
    {errorStats && <>
      <p>Percent of Errors in the last 24h {errorStats.past24h.total > 0 ? Math.ceil(100 * errorStats.past24h.errors / errorStats.past24h.total) : 0}%</p>
      <p>Percent of Errors in the last 6h {errorStats.past6h.total > 0 ? Math.ceil(100 * errorStats.past6h.errors / errorStats.past6h.total) : 0}%</p>
      <p>Percent of Errors in the last 1h {errorStats.past1h.total > 0 ? Math.ceil(100 * errorStats.past1h.errors / errorStats.past1h.total) : 0}%</p>
      <p>Percent of Errors in the last 10m {errorStats.past10m.total > 0 ? Math.ceil(100 * errorStats.past10m.errors / errorStats.past10m.total) : 0}%</p>
      <p>Percent of Errors in the last 1m {errorStats.past1m.total > 0 ? Math.ceil(100 * errorStats.past1m.errors / errorStats.past1m.total) : 0}%</p>
    </>}
    <select style={{ color: "black" }} value={selectedSourceId} onChange={(e) => setSelectedSourceId(e.target.value)}>
      <option value="" hidden>Select Source</option>
      {enabledPaySources.map((item, index) => <option key={index} value={item.pasteField}>{item.label}</option>)}
    </select>
    <br />
    <select style={{ color: "black" }} value={selectedApp} onChange={(e) => setSelectedApp(e.target.value)}>
      <option value="" hidden>Select App</option>
      {apps.map((app, index) => <option key={index} value={app}>{app}</option>)}
    </select>
    <br />
    {selectedApp && selectedSourceId && <>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="auth_in_nano" state={!!selectedMetrics.auth_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, auth_in_nano: e.target.checked })} />
        <label>Auth In (ms)</label>
      </div>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="handle_in_nano" state={!!selectedMetrics.handle_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, handle_in_nano: e.target.checked })} />
        <label>Handle In (ms)</label>
      </div>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="parsed_in_nano" state={!!selectedMetrics.parsed_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, parsed_in_nano: e.target.checked })} />
        <label>Parsed In (ms)</label>
      </div>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <Checkbox id="validate_in_nano" state={!!selectedMetrics.validate_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, validate_in_nano: e.target.checked })} />
        <label>Validate In (ms)</label>
      </div>
      <select style={{ color: "black" }} value={successFilter} onChange={(e) => setSuccessFilter(e.target.value as 'yes' | 'no' | '')}>
        <option value="">Success Or Failure</option>
        <option value="yes">Success</option>
        <option value="no">Failure</option>
      </select>
      <br />
      <select style={{ color: "black" }} value={nostrFilter} onChange={(e) => setNostrFilter(e.target.value as 'yes' | 'no' | '')}>
        <option value="">Nostr Or Http</option>
        <option value="yes">Nostr</option>
        <option value="no">Http</option>
      </select>
    </>}
    <div style={{ display: 'flex', flexWrap: 'wrap' }} >{rows}</div>
  </div>
}
