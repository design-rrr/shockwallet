import { toast } from "react-toastify";
import { Buffer } from 'buffer';
import { getNostrClient } from "../../Api"
import { SpendFrom } from "../../globalTypes"
import * as Types from '../../Api/pub/autogenerated/ts/types'
import { decodeTLVDataPacket, parseTLbV, parseTLV } from "./tlv";
const configuration = { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] }
type IceCandidate = { type: string, candidate?: string, sdpMid?: string, sdpMLineIndex?: number }
export const newWebRtcConnection = async (source: SpendFrom, onReady: (sendFunc: (m: Types.SingleUsageMetricReq) => Promise<Uint8Array>) => void) => {
    const c = await getNostrClient(source.pasteField, source.keys)
    console.log("creating webrtc connection")
    const { setCandidate, offer, peerConnection } = await getWrtcOffer(async (candidate) => {
        await c.SubmitWebRtcMessage({ message: { type: Types.WebRtcMessage_message_type.CANDIDATE, candidate: JSON.stringify(candidate) } })
    }, onReady)
    console.log("subscribing to candidates")
    c.SubToWebRtcCandidates((res) => {
        if (res.status !== 'OK') {
            toast.error('Error connecting webrtc ' + res.reason)
            return
        }
        const candidate = JSON.parse(res.candidate)
        setCandidate(candidate)
    })
    console.log("sending offer")
    const res = await c.SubmitWebRtcMessage({ message: { type: Types.WebRtcMessage_message_type.OFFER, offer: JSON.stringify(offer) } })
    if (res.status !== 'OK') {
        toast.error('Error connecting webrtc ' + res.reason)
        return
    }
    if (!res.answer) {
        toast.error('Error connecting webrtc ' + "??")
        return
    }
    console.log("setting remote description")
    await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(res.answer)))
}
export const getWrtcOffer = async (onCandidate: (candidate: IceCandidate) => {}, onReady: (sendFunc: (m: Types.SingleUsageMetricReq) => Promise<Uint8Array>) => void) => {
    const peerConnection = new RTCPeerConnection(configuration)
    peerConnection.addEventListener('icecandidate', event => {
        const message: IceCandidate = {
            type: 'candidate'
        };
        if (event.candidate) {
            message.candidate = event.candidate.candidate;
            message.sdpMid = event.candidate.sdpMid || undefined;
            message.sdpMLineIndex = event.candidate.sdpMLineIndex || undefined;
        }
        onCandidate(message);
    });
    const setCandidate = async (candidate: IceCandidate) => {
        if (!candidate.candidate) {
            await peerConnection.addIceCandidate(null);
        } else {
            await peerConnection.addIceCandidate(candidate);
        }
    }
    /*     peerConnection.addEventListener('iceconnectionstatechange', (e) => {
            console.log('iceconnectionstatechange', e)
        })
        peerConnection.addEventListener('icegatheringstatechange', (e) => {
            console.log('icegatheringstatechange', e)
        }) */

    peerConnection.addEventListener('connectionstatechange', (e) => {
        console.log('connectionstatechange', peerConnection.connectionState)
    })
    peerConnection.addEventListener('datachannel', (e) => {
        console.log('datachannel', e)
    })
    const chan = peerConnection.createDataChannel('metrics-data')
    let chanOpen = false
    const pendingRequests: Record<number, { cb: (data: Uint8Array) => void }> = {}
    const pendingResponses: Record<number, { totalPackets: number, packets: { index: number, data: Uint8Array }[] }> = {}
    const send = (m: Types.SingleUsageMetricReq): Promise<Uint8Array> => new Promise((resolve, reject) => {
        const reqId = Math.floor(Math.random() * 100_000_000)
        if (pendingRequests[reqId]) {
            reject("request id collision")
            return
        }
        m.request_id = reqId
        console.log("sending request", m)
        if (!chanOpen) {
            return reject("data channel not open")
        }
        pendingRequests[reqId] = { cb: resolve }
        chan.send(JSON.stringify(m))
    })
    chan.onopen = () => {
        chanOpen = true
        onReady(send)
        //chan.send("hello world")
    }
    chan.onclose = () => {
        chanOpen = false
    }
    let logged = 0
    chan.onmessage = (e) => {
        const data = e.data as ArrayBuffer
        const parsed = parseTLbV(new Uint8Array(data))
        const packet = decodeTLVDataPacket(parsed)
        if (!pendingRequests[packet.dataId]) {
            console.log("unexpected response", packet.dataId)
            return
        }
        if (!pendingResponses[packet.dataId]) {
            pendingResponses[packet.dataId] = { totalPackets: packet.totalPackets, packets: [] }
        }
        pendingResponses[packet.dataId].packets.push({ index: packet.packetNum, data: packet.data })
        if (pendingResponses[packet.dataId].packets.length === packet.totalPackets) {
            const sorted = pendingResponses[packet.dataId].packets.sort((a, b) => a.index - b.index)
            const totalSize = sorted.reduce((acc, p) => acc + p.data.length, 0)
            const finalData = new Uint8Array(totalSize)
            let offset = 0
            sorted.forEach(p => {
                finalData.set(p.data, offset)
                offset += p.data.length
            })
            pendingRequests[packet.dataId].cb(finalData)
            delete pendingRequests[packet.dataId]
            delete pendingResponses[packet.dataId]
        }
    }
    console.log("creating offer")
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    return { peerConnection, offer, setCandidate, send }
}