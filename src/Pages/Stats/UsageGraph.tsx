import { toast } from "react-toastify";
import { Buffer } from 'buffer';
import { Chart, Line } from 'react-chartjs-2'
import * as Types from '../../Api/pub/autogenerated/ts/types'
import { useMemo, useState } from 'react'
import { SpendFrom } from "../../globalTypes";
import { getNostrClient } from "../../Api";
import { decodeListTLV, parseTLV, tlvToUsageMetrics } from "./tlv";
import { MetricsDataEntry } from "./statsApi";

export type SelectedMetrics = {
    auth_in_nano?: boolean
    handle_in_nano?: boolean
    parsed_in_nano?: boolean
    validate_in_nano?: boolean
}
type Props = { fetchPage: (page: number) => Promise<Uint8Array>, rpcMethod: string, methodMetrics: MetricsDataEntry<Types.UsageMetric>, success: boolean, failure: boolean, http: boolean, nostr: boolean, selectedMetrics: SelectedMetrics }
export const z = (n: number) => n < 10 ? `0${n}` : `${n}`
export const UsageGraph = ({ fetchPage, rpcMethod, methodMetrics, failure, http, nostr, success, selectedMetrics }: Props) => {
    const [shownPage, setShownPage] = useState<number>(-1)
    const [pagesData, setPagesData] = useState<Record<number, Types.UsageMetric[]>>({})
    const { datasets, labels, from, to } = useMemo(() => {
        const labels = [] as string[]
        const handleInNanoData = [] as number[]
        const authInNanoData = [] as number[]
        const parsedInNanoData = [] as number[]
        const validateInNanoData = [] as number[]
        const pageData = shownPage === -1 ? methodMetrics.entries : pagesData[shownPage] || []
        let min = Number.MAX_SAFE_INTEGER
        let max = 0
        pageData.forEach(metric => {
            if (!metric.success && !failure) return
            if (metric.success && !success) return
            if (!metric.nostr && !http) return
            if (metric.nostr && !nostr) return
            if (metric.processed_at_ms < min) min = metric.processed_at_ms
            if (metric.processed_at_ms > max) max = metric.processed_at_ms
            const d = new Date(metric.processed_at_ms)
            const date = `${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}`
            labels.push(date)
            if (selectedMetrics.auth_in_nano) authInNanoData.push(metric.auth_in_nano / 1000000)
            if (selectedMetrics.handle_in_nano) handleInNanoData.push(metric.handle_in_nano / 1000000)
            if (selectedMetrics.parsed_in_nano) parsedInNanoData.push(metric.parsed_in_nano / 1000000)
            if (selectedMetrics.validate_in_nano) validateInNanoData.push(metric.validate_in_nano / 1000000)
        })
        const datas = [
            { label: "Auth time (ms)", data: authInNanoData, color: '#66c2a5' },
            { label: "Handle time (ms)", data: handleInNanoData, color: '#fee08b' },
            { label: "Parsed time (ms)", data: parsedInNanoData, color: '#5e4fa2' },
            { label: "Validate time (ms)", data: validateInNanoData, color: '#9e0142' },]
        const datasets = datas.filter(({ data }) => data.length > 0).map((d, i) => ({
            label: d.label,
            data: d.data,
            backgroundColor: d.color,
            borderColor: d.color,
            color: d.color,
        }))
        const minTime = new Date(min)
        const from = `${minTime.getFullYear()}-${z(minTime.getMonth() + 1)}-${z(minTime.getDate())} ${z(minTime.getHours())}:${z(minTime.getMinutes())}:${z(minTime.getSeconds())}`
        const maxTime = new Date(max)
        const to = `${maxTime.getFullYear()}-${z(maxTime.getMonth() + 1)}-${z(maxTime.getDate())} ${z(maxTime.getHours())}:${z(maxTime.getMinutes())}:${z(maxTime.getSeconds())}`
        return { datasets, labels, from, to }
    }, [shownPage, pagesData, methodMetrics, selectedMetrics, failure, http, nostr, success])

    const loadMore = async (page: number) => {
        console.log("loading page", page, shownPage)
        if (shownPage === page) return
        setShownPage(page)
        const pageData = await fetchPage(page)
        const tlvList = decodeListTLV(parseTLV(pageData))
        const data = tlvList.map(tlv => tlvToUsageMetrics("", parseTLV(tlv)))
        const moreData = {
            ...pagesData, [page]: data
        }
        setPagesData(moreData)
    }

    return <div key={rpcMethod} style={{ width: 600, border: '1px solid black', textAlign: 'center' }}>
        <h2 >{rpcMethod}</h2>
        <p>{from}</p>
        <p>{to}</p>
        <Line data={{
            labels,
            datasets,
        }} />
        <div >
            {methodMetrics.allPages.map(p =>
                <span style={{ margin: '2px', textDecoration: p === shownPage ? 'underline' : ' none' }}
                    onClick={() => loadMore(p)} key={p}
                >{p}</span>
            )}
            <span style={{ margin: '2px', textDecoration: -1 === shownPage ? 'underline' : ' none' }}
                onClick={() => loadMore(-1)} key={-1}>(last 100)</span>
        </div>
    </div>
} 