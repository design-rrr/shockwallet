import { toast } from "react-toastify";
import { Chart as ChartJS, registerables, Legend } from 'chart.js';
ChartJS.register(...registerables, Legend);
import React, { useEffect, useMemo, useState } from "react";
import { SpendFrom } from "../../globalTypes";
import * as Types from '../../Api/pub/autogenerated/ts/types'
import Checkbox from "../../Components/Checkbox";
import { SelectedMetrics, UsageGraph, z } from "./UsageGraph";
import { newWebRtcConnection } from "./webRTC";
import { BundleDataPoint, fetchBundleStats, fetchErrors, fetchUsageStats, MetricsData } from "./statsApi";
import { BundleGraph } from "./BundleGraph";
import { ErrorsView } from "./ErrorsView";
//import { MetricsData } from "./StatsGraph";
type OfferItemType = {
    title: string;
    value: string;
    type: string;
};
//const z = (n: number) => n < 10 ? `0${n}` : `${n}`
//export type MetricsData = { entries: Types.UsageMetric[], currentPage: number, allPages: number[] }

type PagedData = Record<string, Record<string, Record<number, Types.UsageMetric[]>>>
/* type SelectedMetrics = {
  auth_in_nano?: boolean
  handle_in_nano?: boolean
  parsed_in_nano?: boolean
  validate_in_nano?: boolean
} */

export const Graphs = ({ selectedSource }: { selectedSource: SpendFrom }) => {
    const [apps, setApps] = useState<string[]>([])
    const [bundleData, setBundleData] = useState<MetricsData<BundleDataPoint>>()
    const [usageData, setUsageData] = useState<MetricsData<Types.UsageMetric>>()
    const [usageGraphs, setUsageGraphs] = useState<Record<string, boolean>>({})
    const [bundleGraphs, setBundleGraphs] = useState<Record<string, boolean>>({})
    const [sendWrtcReq, setSendWrtcReq] = useState<{ f: (m: Types.SingleMetricReq) => Promise<Uint8Array> }>()
    //const [moreData, setMoreData] = useState<PagedData>()
    const [selectedApp, setSelectedApp] = useState<string>('')
    const [selectedMetrics, setSelectedMetrics] = useState<SelectedMetrics>({ handle_in_nano: true })
    const [success, setSuccess] = useState(true)
    const [nostr, setNostr] = useState(true)
    const [failure, setFailure] = useState(true)
    const [http, setHttp] = useState(true)
    /*     const [successFilter, setSuccessFilter] = useState<'yes' | 'no' | ''>("")
        const [nostrFilter, setNostrFilter] = useState<'yes' | 'no' | ''>("") */
    const [errorStats, setErrorStats] = useState<Types.ErrorStats>()

    const [tab, setTab] = useState<'usage' | 'bundle'>('usage')

    const updateApps = (newApps: string[]) => {
        const r: Record<string, boolean> = {}
        newApps.forEach(app => r[app] = true)
        apps.forEach(app => r[app] = true)
        const keys = Object.keys(r).sort()
        setApps(keys)

    }

    useEffect(() => {
        if (!selectedSource) return
        newWebRtcConnection(selectedSource, (sendFunc) => {
            console.log("wrtc is ready")
            setSendWrtcReq({ f: sendFunc })
        })
    }, [selectedSource])

    useEffect(() => {
        if (!selectedSource) return
        fetchErrors(selectedSource).then(({ errors }) => setErrorStats(errors)).catch((e) => toast.error(e.message))
    }, [selectedSource])

    useEffect(() => {
        if (!selectedSource || tab !== 'usage' || !!usageData) return
        fetchUsageStats(selectedSource).then(({ usageData, apps }) => {
            setUsageData(usageData)
            updateApps(apps)
        }).catch((e) => toast.error(e.message))
    }, [selectedSource, tab, usageData])

    useEffect(() => {
        if (!selectedSource || tab !== 'bundle' || !!bundleData) return
        fetchBundleStats(selectedSource).then(({ bundleData, apps }) => {
            setBundleData(bundleData)
            updateApps(apps)
        }).catch((e) => toast.error(e.message))
    }, [selectedSource, tab, bundleData])

    useEffect(() => {
        if (!selectedApp || !usageData) return
        const keys = usageData[selectedApp] ? Object.keys(usageData[selectedApp]) : []
        const graphs = {} as Record<string, boolean>
        keys.forEach(k => graphs[k] = true)
        setUsageGraphs(graphs)
    }, [selectedApp, usageData])

    useEffect(() => {
        if (!selectedApp || !bundleData) return
        const keys = bundleData[selectedApp] ? Object.keys(bundleData[selectedApp]) : []
        const graphs = {} as Record<string, boolean>
        keys.forEach(k => graphs[k] = true)
        setBundleGraphs(graphs)
    }, [selectedApp, bundleData])

    const usageRows = useMemo(() => {
        if (!usageData || !usageData[selectedApp]) return []
        return Object.keys(usageData[selectedApp]).filter(method => usageGraphs[method]).map((rpcMethod) => {
            const methodMetrics = usageData[selectedApp][rpcMethod]
            return <UsageGraph key={rpcMethod} fetchPage={(page) => {
                if (!sendWrtcReq) {
                    throw new Error('No wrtc connection')
                }
                console.log("fetching...")
                return sendWrtcReq.f({ app_id: selectedApp, metrics_name: rpcMethod, page, metric_type: Types.SingleMetricType.USAGE_METRIC })
            }} rpcMethod={rpcMethod}
                methodMetrics={methodMetrics} success={success} failure={failure} nostr={nostr} http={http} selectedMetrics={selectedMetrics} />
        })
    }, [selectedApp, selectedMetrics, success, failure, nostr, http, usageData, usageGraphs])


    const bundleRows = useMemo(() => {
        if (!bundleData || !bundleData[selectedApp]) return []
        return Object.keys(bundleData[selectedApp]).filter(method => bundleGraphs[method]).map((bundleId) => {
            const bundleMetrics = bundleData[selectedApp][bundleId]
            return <BundleGraph key={bundleId} fetchPage={(page) => {
                if (!sendWrtcReq) {
                    throw new Error('No wrtc connection')
                }
                console.log("fetching...")
                return sendWrtcReq.f({ app_id: selectedApp, metrics_name: bundleId, page, metric_type: Types.SingleMetricType.BUNDLE_METRIC })
            }} bundleId={bundleId}
                bundleMetrics={bundleMetrics} />
        })
    }, [selectedApp, selectedMetrics, bundleData, bundleGraphs])

    return <div>
        <h1 style={{ textAlign: 'center' }}>Errors</h1>
        {errorStats && <ErrorsView errors={errorStats} />}
        <br />
        <div >
            <div style={{ display: 'flex', flexDirection: 'column', width: '50%', textAlign: 'center', margin: '20px auto', padding: 20, border: '1px solid white', borderRadius: 10 }}>
                <label>Select App:</label>
                <select style={{ color: "black" }} value={selectedApp} onChange={(e) => setSelectedApp(e.target.value)}>
                    <option value="" hidden>Select App</option>
                    {apps.map((app, index) => <option key={index} value={app}>{app}</option>)}
                </select>
            </div>
        </div>
        <div style={{ display: 'flex', justifyContent: 'center' }}>
            <div style={{ ...tabStyle(tab === 'usage'), textAlign: 'center', position: 'relative', bottom: -1 }} onClick={() => setTab('usage')}>Usage Stats</div>
            <div style={{ ...tabStyle(tab === 'bundle'), textAlign: 'center', position: 'relative', bottom: -1 }} onClick={() => setTab('bundle')}>Bundle Stats</div>
        </div>
        <div style={{ border: '1px solid white', width: '100%', minHeight: 10, borderRadius: '10px' }}>
            {!selectedApp && <p style={{ textAlign: 'center', margin: 10 }}>Select an app to continue...</p>}

            {tab === 'usage' && <>
                {selectedApp && !usageData && <p style={{ textAlign: 'center', margin: 10 }}>Loading...</p>}
                {selectedApp && usageData && !usageData[selectedApp] && <p style={{ textAlign: 'center', margin: 10 }}>No Data Available For Selected App</p>}
                {selectedApp && usageData && usageData[selectedApp] && <div style={{ display: 'flex' }}>
                    <div style={{ border: '1px solid grey', borderRadius: 10, padding: 10, margin: 10 }}>
                        <h2>Show Datsets</h2>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="auth_in_nano" state={!!selectedMetrics.auth_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, auth_in_nano: e.target.checked })} />
                            <label>Show Auth In (ms)</label>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="handle_in_nano" state={!!selectedMetrics.handle_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, handle_in_nano: e.target.checked })} />
                            <label>Show Handle In (ms)</label>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="parsed_in_nano" state={!!selectedMetrics.parsed_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, parsed_in_nano: e.target.checked })} />
                            <label>Show Parsed In (ms)</label>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="validate_in_nano" state={!!selectedMetrics.validate_in_nano} setState={(e) => setSelectedMetrics({ ...selectedMetrics, validate_in_nano: e.target.checked })} />
                            <label>Show Validate In (ms)</label>
                        </div>
                    </div>
                    <div style={{ border: '1px solid grey', borderRadius: 10, padding: 10, margin: 10 }}>
                        <h2>Show Datapoints</h2>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="sucess_result" state={success} setState={(e) => setSuccess(e.target.checked)} />
                            <label>Show Success Result</label>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="failure_result" state={failure} setState={(e) => setFailure(e.target.checked)} />
                            <label>Show Failure Result</label>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="nostr_result" state={nostr} setState={(e) => setNostr(e.target.checked)} />
                            <label>Show Handled With Nostr</label>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id="http_result" state={http} setState={(e) => setHttp(e.target.checked)} />
                            <label>Show Handled With Http</label>
                        </div>
                    </div>
                    <div style={{ border: '1px solid grey', borderRadius: 10, padding: 10, margin: 10, maxHeight: 200, overflowY: 'scroll' }}>
                        <h2>Show Graphs</h2>
                        {Object.keys(usageData[selectedApp]).map(m => <div key={m} style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id={m} state={!!usageGraphs[m]} setState={(e) => setUsageGraphs(g => ({ ...g, [m]: e.target.checked }))} />
                            <label>{m}</label>
                        </div>)}
                    </div>
                </div>}
                <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>{usageRows}</div>
            </>}
            {tab === 'bundle' && <>
                {selectedApp && !bundleData && <p style={{ textAlign: 'center', margin: 10 }}>Loading...</p>}
                {selectedApp && bundleData && !bundleData[selectedApp] && <p style={{ textAlign: 'center', margin: 10 }}>No Data Available For Selected App</p>}
                {selectedApp && bundleData && bundleData[selectedApp] && <div style={{ display: 'flex' }}>
                    <div style={{ border: '1px solid grey', borderRadius: 10, padding: 10, margin: 10, maxHeight: 200, overflowY: 'scroll' }}>
                        <h2>Show Graphs</h2>
                        {Object.keys(bundleData[selectedApp]).map(m => <div key={m} style={{ display: 'flex', alignItems: 'center' }}>
                            <Checkbox id={m} state={!!bundleGraphs[m]} setState={(e) => setBundleGraphs(g => ({ ...g, [m]: e.target.checked }))} />
                            <label>{m}</label>
                        </div>)}
                    </div>
                </div>}
                <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>{bundleRows}</div>
            </>}
        </div>
    </div>
}


const tabStyle = (selected: boolean) => ({
    backgroundColor: !selected ? 'white' : '#16191c',
    width: 200,
    height: 40,
    color: !selected ? '#16191c' : 'white',
    borderRadius: '4px 4px 0 0',
    margin: '0 5px',
    border: !selected ? '' : '1px solid white',
    borderBottom: !selected ? '' : '1px solid #16191c',
})