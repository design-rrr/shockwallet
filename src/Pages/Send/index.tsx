import React, { useCallback, useEffect, useState } from 'react';
import { getNostrClient } from '../../Api'
import { notification } from 'antd';
import { validate } from 'bitcoin-address-validation';


//It import svg icons library
import * as Icons from "../../Assets/SvgIconLibrary";
import { UseModal } from '../../Hooks/UseModal';
import { useSelector, useDispatch } from '../../State/store';
import type { NotificationPlacement } from 'antd/es/notification/interface';
import axios, { isAxiosError } from 'axios';
import { useIonRouter } from '@ionic/react';
import { Modal } from '../../Components/Modals/Modal';
import SpendFromDropdown from '../../Components/Dropdowns/SpendFromDropdown';

import { defaultMempool } from '../../constants';
import { classifyBitcoinInput, InputClassification } from '../../constants';
import { setLatestOperation } from '../../State/Slices/HistorySlice';
import { parseNprofile } from '../../Api/nostr';
import * as Types from '../../Api/autogenerated/ts/types'
import { ChainFeesInter } from '../Prefs';
import { setDebugMode } from '../../State/Slices/prefsSlice';
import useDebounce from '../../Hooks/useDebounce';
import { decode } from "@gandlaf21/bolt11-decode";
import { bech32 } from 'bech32';

interface Destination {
  type: InputClassification,
  data: string,
  callback?: string,
  min?: number,
  max?: number,
}


export const Send = () => {

  const price = useSelector((state) => state.usdToBTC);

  //reducer
  const dispatch = useDispatch();
  const spendSources = useSelector((state) => state.spendSource).map((e) => { return { ...e } });
  const mempoolUrl = useSelector(({ prefs }) => prefs.mempoolUrl) || defaultMempool;
  const selectedChainFee = useSelector(({ prefs }) => prefs.selected);





  const [vReceive, setVReceive] = useState(1);
  const [amountAssets, setAmountAssets] = useState("sats");
  const [amount, setAmount] = useState(0);
  const [decodedAmount, setDecodedAmount] = useState(0);
  const [note, setNote] = useState("");
  const { isShown, toggle } = UseModal();
  const [selectedSource, setSelectedSource] = useState(spendSources[0]);

  
  const [satsPerByte, setSatsPerByte] = useState(0)

  
  const [to, setTo] = useState("");
  const debouncedTo = useDebounce(to, 500);
  const [destination, setDestination] = useState<Destination>({
    type: InputClassification.UNKNOWN,
    data: "",
  });
  const router = useIonRouter();

  const [api, contextHolder] = notification.useNotification();
  const openNotification = useCallback((placement: NotificationPlacement, header: string, text: string) => {
    api.info({
      message: header,
      description:
        text,
      placement
    });
  }, [api]);

  const updateSatsPerByte = useCallback(async () => {
    const res = await axios.get(mempoolUrl)
    const data = res.data as ChainFeesInter
    if (!selectedChainFee) {
      setSatsPerByte(data.economyFee)
      return
    }
    switch (selectedChainFee) {
      case "eco": {
        console.log("eco!")
        setSatsPerByte(data.economyFee)
        break
      }
      case "avg": {
        console.log("avg!")
        setSatsPerByte(Math.ceil((data.hourFee + data.halfHourFee) / 2))
        break
      }
      case "asap": {
        console.log("asap!")
        setSatsPerByte(data.fastestFee)
      }
    }
  }, [mempoolUrl, selectedChainFee]);


  useEffect(() => {
    if (spendSources.length === 0) {
      setTimeout(() => {
        router.push("/home");
      }, 1000);
      return openNotification("top", "Error", "You don't have any source!");
    }
  }, [router, spendSources, openNotification]);

  useEffect(() => {
    const queryString = router.routeInfo.search;
    if (queryString) {
      const value = queryString.substring("?url=".length);
      setTo(value);
    }
  }, [router]);


  useEffect(() => {
    const determineReceiver = async () => {
      if (debouncedTo) {
        const returned = classifyBitcoinInput(debouncedTo);
        switch(returned.type) {
          case InputClassification.LN_INVOICE: {
            const result = await decodeInvoice(returned.data) as number;
            if (!result) {
              openNotification("top", "Error", "Invalid invoice");
              return;
            }
            setDecodedAmount(result);
            setDestination(returned);
            break;
          }
          case InputClassification.BITCOIN_ADDRESS: {
            const valid = validate(returned.data);
            if (!valid) {
              openNotification("top", "Error", "Invalid bitcoin address");
              return;
            }
            if (!selectedSource.pasteField.includes("nprofile")) {
              openNotification("top", "Error", "Cannot do on-chain from lnurl-withdraw");
              return;
            }
            updateSatsPerByte();
            setDestination(returned);
            break;
          }
          case InputClassification.LNURL: {
            try {
              const { words } = bech32.decode(returned.data, 2000);
              const sourceURL = bech32.fromWords(words);
              const buffer = new Uint8Array(sourceURL);
              const decoder = new TextDecoder();
              const lnurl = decoder.decode(buffer);
              const res = await axios.get(lnurl);
              if (res.data.tag !== "payRequest") {
                openNotification("top", "Error", "Lnurl can only be lnurl-pay");
                return;
              }
              setDestination({
                ...returned,
                callback: res.data.callback,
                min: parseInt(res.data.minSendable) / 1000,
                max: parseInt(res.data.maxSendable) / 1000
              });
              break;
            } catch (err) {
              if (isAxiosError(err)) {
                if (err.response) {
                  console.log(err.response, err.response.data);
                  openNotification("top", "Error", err.response.data.reason);
                }
              } else {
                // data conversion error
                openNotification("top", "Error", "Invalid lnurl provided");
              }
              console.log(err);
              return;
            }
          }
          case InputClassification.LN_ADDRESS: {
            const payLink = "https://" + returned.data.split("@")[1] + "/.well-known/lnurlp/" + returned.data.split("@")[0];
            try {
              const res = await axios.get(payLink);
              setDestination({
                ...returned,
                callback: res.data.callback,
                min: parseInt(res.data.minSendable) / 1000,
                max: parseInt(res.data.maxSendable) / 1000
              });
            } catch (e) {
              console.log(e);

            }
          }
        }
      }
    }
    determineReceiver();
  }, [debouncedTo])

  const [loading, setLoading] = useState("none");
  const checkDebugModeInput = () => {
    if (to === 'howdoyouturnthison') {
      dispatch(setDebugMode(true))
      router.push("/home")
      return true
    }
    if (to === 'howdoyouturnthisoff') {
      dispatch(setDebugMode(false))
      router.push("/home")
      return true
    }
    return false
  }
  const handleSubmit = async () => {
    if (checkDebugModeInput()) {
      return
    }
    if (destination.type === InputClassification.UNKNOWN) {
      return;
    }
    setLoading("flex");
    switch (destination.type) {
      case InputClassification.LN_INVOICE: {
        await handlePayInvoice(destination.data);
        break;
      }
      case (InputClassification.LN_ADDRESS): {
      
        await handlePayLnurlPay();
        break;
      }
      case InputClassification.LNURL: {
        console.log("lnurl");
        await handlePayLnurlPay();
        break;
      }
      case InputClassification.BITCOIN_ADDRESS: {
        handlePayBitcoinAddress();
      }
    }

  }


  const paymentSuccess = useCallback((amount: number, identifier: string, type: Types.UserOperationType, { operation_id, network_fee, service_fee }: { operation_id: string, network_fee: number, service_fee: number }) => {
    setTimeout(() => {
      router.push("/home")
    }, 500);
    const { pubkey } = parseNprofile(selectedSource.pasteField)
    const now = Date.now() / 1000
    dispatch(setLatestOperation({
      pub: pubkey, operation: {
        amount, identifier, inbound: false, operationId: operation_id, paidAtUnix: now, type, network_fee, service_fee,
        confirmed: false,
      }
    }))
    return openNotification("top", "Success", "Successfully paid.");
  }, [dispatch, openNotification, router, selectedSource])

  const handlePayBitcoinAddress = useCallback(async () => {

    try {
      const payRes = await (await getNostrClient(selectedSource.pasteField)).PayAddress({
        address: destination.data,
        amoutSats: +amount,
        satsPerVByte: satsPerByte
      })
      if (payRes.status == "OK") {
        return paymentSuccess(+amount, destination.data, Types.UserOperationType.OUTGOING_TX, payRes)
      } else {
        return openNotification("top", "Error", payRes.reason);
      }
    } catch (error) {
      console.log(error)
      return openNotification("top", "Error", "Couldn't send using this info.");
    }
  }, [destination, amount, openNotification, paymentSuccess, satsPerByte, selectedSource])



  const handlePayInvoice = useCallback(async (invoice: string) => {
    if (selectedSource.pasteField.includes("nprofile")) {
      try {
        const result = await (await getNostrClient(selectedSource.pasteField)).DecodeInvoice({ invoice: invoice });
        if (result.status !== "OK") {
          return;
        }
        const payRes = await (await getNostrClient(selectedSource.pasteField)).PayInvoice({
          invoice: invoice,
          amount: 0,
        })
        if (payRes.status == "OK") {
          return paymentSuccess(result.amount, invoice, Types.UserOperationType.OUTGOING_INVOICE, payRes)
        } else {
          return openNotification("top", "Error", payRes.reason);
        }
      } catch (error) {
        console.log(error);
        return openNotification("top", "Error", "Couldn't send using this info.");
      }
    } else {
      // lnurl-withdraw source
      const { words } = bech32.decode(selectedSource.pasteField, 2000);
      const sourceURL = bech32.fromWords(words);
      const buffer = new Uint8Array(sourceURL);
      const decoder = new TextDecoder();
      const lnurl = decoder.decode(buffer);
      try {
        const res = await axios.get(lnurl);
        const { k1, callback } = res.data as { k1: string, callback: string };
        const resp = await axios.get(
          callback + (callback.includes('?') ? "&" : "?") + "k1=" + k1 + "&" + "pr=" + invoice,
          {
            headers: {
              'Content-Type': 'application/json',
              withCredentials: false,
            }
          }
        );
        if (resp.data.status === "Error") {
          openNotification("top", "Error", res.data.reason);
        } else {
          //paymentSuccess(+amount, resp.data.pr, Types.UserOperationType.OUTGOING_INVOICE, { operation_id })
          openNotification("top", "Success", "Paid successfuly");
          router.push("/home");
        }
      } catch (err) {
        console.log(err)
      }
    }
  }, [paymentSuccess, selectedSource, openNotification, router])

  const handlePayLnurlPay = useCallback(async () => {
    const { callback, min } = destination as { callback: string, min: number, max: number };
    try {
      const resp = await axios.get(
        callback + (callback.includes('?') ? "&" : "?") + "amount=" + (amount === 0 ? min * 1000 : amount * 1000),
        {
          headers: {
            'Content-Type': 'application/json',
            withCredentials: false,
          }
        }
      );
      console.log(resp);

      if (resp.data.status === "ERROR") {
        return openNotification("top", "Error", resp.data.error);
      }


      handlePayInvoice(resp.data.pr);
    } catch (err) {
      console.log(err)
    }
  }, [destination, amount, openNotification, handlePayInvoice]);


  
  const decodeInvoice = async (input: string) => {
    try {
      const decodedInvoice = decode(input);
      const amountSection = decodedInvoice.sections.filter(section => section.name === "amount");
      if (amountSection.length>0) {
        return amountSection[0].value/1000;
      }else {
        return null;
      }
    } catch (error) {
      return null
    }
  }





  const confirmContent = <React.Fragment>
    <div className="Sources_notify">
      <div className="Sources_notify_title">Amount to Receive</div>
      <button className="Sources_notify_button" onClick={toggle}>OK</button>
    </div>
  </React.Fragment>;

/*   const test = (qrcode: string) => {
    try {
      let { words: dataPart } = bech32.decode(qrcode.substring("lightning:".length), 2000);
      const sourceURL = bech32.fromWords(dataPart);
      console.log(sourceURL)
      const lnurlLink = new Uint8Array(sourceURL);
      const decoder = new TextDecoder();
      console.log(decoder.decode(lnurlLink))

      //case withdraw link

      //case deposite link
      
      return;
    } catch (error) {
      console.log("haha", error)
    }
  } */

  return (
    <div className='Send_container'>
      <div className='Send_loading' style={{ display: loading }}>
        <div className='Send_img'>
          {Icons.Animation()}
          <p>Sending</p>
        </div>
      </div>
      {contextHolder}
      <div className="Send" style={{ opacity: vReceive, zIndex: vReceive ? 1000 : -1 }}>
        <div className="Send_header_text">Send Payment</div>
        <div className="Send_config">
          <div className="Send_amount">
            Amount:
            <div className='Send_amount_container'>
              <div className="Send_maxButton">
                {decodedAmount === 0 ? <button onClick={() => { setAmount(parseInt(selectedSource.balance)) }}>Max</button> : <div></div>}
              </div>
              <input className="Send_amount_input" type="number" value={decodedAmount || amount} readOnly={decodedAmount !== 0} onChange={(e) => { setAmount(+e.target.value) }} />
              <button onClick={() => { setAmountAssets(amountAssets === "BTC" ? "sats" : "BTC") }}>{amountAssets}</button>
            </div>
          </div>
          <div className='Send_available_amount'>
            {!!satsPerByte && <div className='Send_available_amount_sats'>
              <input type='number' value={satsPerByte} onChange={e => setSatsPerByte(+e.target.value)} />
              sats per byte
            </div>}
            <p className='Send_available_amount_amount'>
              ~ ${amount === 0 ? 0 : (amount * price.buyPrice * (amountAssets === "BTC" ? 1 : 0.00000001)).toFixed(2)}
            </p>
          </div>
          <div className="Send_to">
            <p>To:</p>
            <input type="text" placeholder="Invoice, Bitcoin or Lightning Address, nPub, Email" value={to} onChange={(e) => setTo(e.target.value.toLocaleLowerCase())} />
          </div>
          <div className="Send_for">
            <p>For:</p>
            <input type="text" placeholder="Add a note" value={note} onChange={(e) => { setNote(e.target.value) }} />
          </div>
          <div className="Send_from">
            <p>Spend From:</p>
            <SpendFromDropdown values={spendSources} initialValue={spendSources[0]} callback={setSelectedSource} />
          </div>
        </div>
      </div>
      <div className="Send_other_options">
        <div className="Send_lnurl">
          <div className="Send_set_amount_copy">
            <button onClick={() => { router.push("/home") }}>{Icons.Close()}CANCEL</button>
          </div>
        </div>
        <div className="Send_chain">
          <div className="Send_set_amount_copy">
            <button onClick={handleSubmit}>{Icons.send()}SEND</button>
          </div>
        </div>
      </div>
      <Modal isShown={isShown} hide={toggle} modalContent={confirmContent} headerText={''} />
    </div>
  )
}