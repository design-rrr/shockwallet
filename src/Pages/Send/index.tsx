import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { PageProps, SpendFrom } from "../../globalTypes";
import { getNostrClient } from '../../Api'
import { notification } from 'antd';
import { validate, getAddressInfo } from 'bitcoin-address-validation';


//It import svg icons library
import * as Icons from "../../Assets/SvgIconLibrary";
import { AddressType, PayAddressResponse, PayInvoiceResponse } from '../../Api/autogenerated/ts/types';
import { UseModal } from '../../Hooks/UseModal';
import { useSelector, useDispatch } from '../../State/store';
import type { NotificationPlacement } from 'antd/es/notification/interface';
import axios from 'axios';
import { useIonRouter } from '@ionic/react';
import { Modal } from '../../Components/Modals/Modal';
import SpendFromDropdown from '../../Components/Dropdowns/SpendFromDropdown';
import { useLocation } from 'react-router-dom';
import { addAddressbookLink } from '../../State/Slices/addressbookSlice';
import { NOSTR_PUB_DESTINATION, NOSTR_RELAYS, defaultMempool, usdToBTCSpotLink } from '../../constants';
import { classifyBitcoinInput, InputClassification } from '../../constants';
import { setLatestOperation } from '../../State/Slices/HistorySlice';
import { parseNprofile } from '../../Api/nostr';
import * as Types from '../../Api/autogenerated/ts/types'
import { ChainFeesInter } from '../Prefs';
import { setDebugMode } from '../../State/Slices/prefsSlice';
import useDebounce from '../../Hooks/useDebounce';
import { decode } from "@gandlaf21/bolt11-decode";

export const Send = () => {

  const price = useSelector((state) => state.usdToBTC);

  //reducer
  const dispatch = useDispatch();
  const paySource = useSelector((state) => state.paySource).map((e) => { return { ...e } });
  const spendSources = useSelector((state) => state.spendSource).map((e) => { return { ...e } });
  const mempoolUrl = useSelector(({ prefs }) => prefs.mempoolUrl) || defaultMempool;
  const BTCUSDUrl = useSelector(({ prefs }) => prefs.BTCUSDUrl) || usdToBTCSpotLink;
  const selectedChainFee = useSelector(({ prefs }) => prefs.selected);

  useEffect(() => {
    const func = async () => {
      const result = await (await getNostrClient(selectedSource.pasteField)).GetLnurlWithdrawLink();
      console.log("here is the result", result)
    }
    func()
  }, [])


  const [error, setError] = useState("")
  const [vReceive, setVReceive] = useState(1);
  const [amountAssets, setAmountAssets] = useState("sats");
  const [amount, setAmount] = useState(0);
  const [decodedAmount, setDecodedAmount] = useState(0);
  const [note, setNote] = useState("");
  const { isShown, toggle } = UseModal();
  const [selectedSource, setSelectedSource] = useState(spendSources[0]);
  const sourceType = useMemo(() => {
    if (selectedSource.pasteField.includes("nprofile")) {
      return "nprofile";
    } else if (selectedSource.pasteField.includes("@")) {
      return ""
    }
  }, [selectedSource])
  
  const [satsPerByte, setSatsPerByte] = useState(0)
  const nostrSource = paySource.filter((e: any) => e.pasteField.includes("nprofile"))
  
  const [to, setTo] = useState("");
  const debouncedTo = useDebounce(to, 500);
  const [destination, setDestination] = useState(InputClassification.UNKNOWN);
  const router = useIonRouter();

  const [api, contextHolder] = notification.useNotification();
  const openNotification = useCallback((placement: NotificationPlacement, header: string, text: string) => {
    api.info({
      message: header,
      description:
        text,
      placement
    });
  }, [api]);

  const updateSatsPerByte = useCallback(async () => {
    const res = await axios.get(mempoolUrl)
    const data = res.data as ChainFeesInter
    if (!selectedChainFee) {
      setSatsPerByte(data.economyFee)
      return
    }
    switch (selectedChainFee) {
      case "eco": {
        console.log("eco!")
        setSatsPerByte(data.economyFee)
        break
      }
      case "avg": {
        console.log("avg!")
        setSatsPerByte(Math.ceil((data.hourFee + data.halfHourFee) / 2))
        break
      }
      case "asap": {
        console.log("asap!")
        setSatsPerByte(data.fastestFee)
      }
    }
  }, [mempoolUrl, selectedChainFee]);


  useEffect(() => {
    if (spendSources.length === 0) {
      setTimeout(() => {
        router.push("/home");
      }, 1000);
      return openNotification("top", "Error", "You don't have any source!");
    }
  }, [router, spendSources, openNotification]);

  useEffect(() => {
    const queryString = router.routeInfo.search;
    if (queryString) {
      const value = queryString.substring("?url=".length);
      setTo(value);
    }
  }, [router]);


  useEffect(() => {
    const determineReceiver = async () => {
      if (debouncedTo) {
        const returned = classifyBitcoinInput(debouncedTo);
        switch(returned.type) {
          case InputClassification.LN_INVOICE: {
            const result = await (await getNostrClient("")).DecodeInvoice({ invoice: returned.data });
            if (result.status !== "OK") {
              return;
            }
            console.log("the result is", result)
          }
        }
      }
    }
    determineReceiver();
  }, [debouncedTo])

  const [loading, setLoading] = useState("none");
  const checkDebugModeInput = () => {
    if (to === 'howdoyouturnthison') {
      dispatch(setDebugMode(true))
      router.push("/home")
      return true
    }
    if (to === 'howdoyouturnthisoff') {
      dispatch(setDebugMode(false))
      router.push("/home")
      return true
    }
    return false
  }
  const handleSubmit = async () => {
    if (checkDebugModeInput()) {
      return
    }
    setLoading("flex")
    if (selectedSource.pasteField.includes("nprofile")) {
      await payUsingNprofile();
      setLoading("none")
    } else {

    }
  }

  const paymentSuccess = (amount: number, identifier: string, type: Types.UserOperationType, { operation_id, network_fee, service_fee }: { operation_id: string, network_fee: number, service_fee: number }) => {
    setTimeout(() => {
      router.push("/home")
    }, 500);
    const { pubkey } = parseNprofile(selectedSource.pasteField)
    const now = Date.now() / 1000
    dispatch(setLatestOperation({
      pub: pubkey, operation: {
        amount, identifier, inbound: false, operationId: operation_id, paidAtUnix: now, type, network_fee, service_fee,
        confirmed: false,
      }
    }))
    return openNotification("top", "Success", "Successfully paid.");
  }

  const payLNAddress = async () => {
    try {
      const payLink = "https://" + to.split("@")[1] + "/.well-known/lnurlp/" + to.split("@")[0];
      const res = await axios.get(payLink);
      const callbackURL = await axios.get(
        res.data.callback + (res.data.callback.includes('?') ? "&" : "?") + "amount=" + (amount === 0 ? res.data.minSendable : amount * 1000),
        {
          headers: {
            'Content-Type': 'application/json',
            withCredentials: false,
          }
        }
      );
      console.log(callbackURL);

      if (callbackURL.data.success === false) {
        return openNotification("top", "Error", callbackURL.data.error);
      }
      const client = await getNostrClient(selectedSource.pasteField)

      const payRes = await (await getNostrClient(selectedSource.pasteField)).PayInvoice({
        invoice: callbackURL.data.pr,
        amount: +amount,
      })
      if (payRes.status == "OK") {
        dispatch(addAddressbookLink({
          identifier: callbackURL.data.pr,
          address: to
        }))
        return paymentSuccess(+amount, callbackURL.data.pr, Types.UserOperationType.OUTGOING_INVOICE, payRes)
      } else {
        return openNotification("top", "Error", payRes.reason);
      }
    } catch (error) {
      console.log(error)
      return openNotification("top", "Error", "Couldn't send using this info.");
    }
  }

  const payUsingNprofile = async () => {
    const expression: RegExp = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    let dst = to.toLowerCase()
    if (dst.startsWith("lightning:")) {
      dst = dst.slice("lightning:".length)
    }
    if (dst.startsWith("bitcoin:")) {
      dst = dst.slice("bitcoin:".length)
    }
    if (expression.test(dst)) {
      await payLNAddress()
      return
    }
    if (dst.startsWith("lnbc")) {
      try {
        const result = await (await getNostrClient(selectedSource.pasteField)).DecodeInvoice({ invoice: dst });
        if (result.status != "OK") {
          return;
        }
        const payRes = await (await getNostrClient(selectedSource.pasteField)).PayInvoice({
          invoice: dst,
          amount: +amount,
        })
        if (payRes.status == "OK") {
          return paymentSuccess(result.amount, dst, Types.UserOperationType.OUTGOING_INVOICE, payRes)
        } else {
          return openNotification("top", "Error", payRes.reason);
        }
      } catch (error) {
        console.log(error);
        return openNotification("top", "Error", "Couldn't send using this info.");
      }
    }
    if (validate(dst)) {
      try {
        const payRes = await (await getNostrClient(selectedSource.pasteField)).PayAddress({
          address: dst,
          amoutSats: +amount,
          satsPerVByte: satsPerByte
        })
        if (payRes.status == "OK") {
          return paymentSuccess(+amount, dst, Types.UserOperationType.OUTGOING_TX, payRes)
        } else {
          return openNotification("top", "Error", payRes.reason);
        }
      } catch (error) {
        console.log(error)
        return openNotification("top", "Error", "Couldn't send using this info.");
      }
    }
  }

  const decodeInvoice = async (input: string) => {
    if (input.startsWith("lightning:")) {
      input = input.slice("lightning:".length)
    }

    if (!input.startsWith("lnbc")) {
      return null
    }
    try {
      const decodedInvoice = decode(input);
      const amountSection = decodedInvoice.sections.filter(section => section.name === "amount");
      if (amountSection.length>0) {
        return amountSection[0].value/1000;
      }else {
        return null;
      }
    } catch (error) {
      return null
    }
  }
  const validateAddress = async (input: string) => {
    if (input.startsWith("bitcoin:")) {
      input = input.slice("bitcoin:".length)
    }
    try {
      return validate(input)
    } catch (error) {
      return false
    }
  }

  const onChangeTo = async (e: string) => {
    setTo(e);
    let input = e.toLowerCase()
    const decodedAmount = await decodeInvoice(input);

    if (decodedAmount !== null) {
      setDecodedAmount(decodedAmount)
      return
    }
    if (await validateAddress(input)) {
      updateSatsPerByte()
    }
  }

  const confirmContent = <React.Fragment>
    <div className="Sources_notify">
      <div className="Sources_notify_title">Amount to Receive</div>
      <button className="Sources_notify_button" onClick={toggle}>OK</button>
    </div>
  </React.Fragment>;

/*   const test = (qrcode: string) => {
    try {
      let { words: dataPart } = bech32.decode(qrcode.substring("lightning:".length), 2000);
      const sourceURL = bech32.fromWords(dataPart);
      console.log(sourceURL)
      const lnurlLink = new Uint8Array(sourceURL);
      const decoder = new TextDecoder();
      console.log(decoder.decode(lnurlLink))

      //case withdraw link

      //case deposite link
      
      return;
    } catch (error) {
      console.log("haha", error)
    }
  } */

  return (
    <div className='Send_container'>
      <div className='Send_loading' style={{ display: loading }}>
        <div className='Send_img'>
          {Icons.Animation()}
          <p>Sending</p>
        </div>
      </div>
      {contextHolder}
      <div className="Send" style={{ opacity: vReceive, zIndex: vReceive ? 1000 : -1 }}>
        <div className="Send_header_text">Send Payment</div>
        <div className="Send_config">
          <div className="Send_amount">
            Amount:
            <div className='Send_amount_container'>
              <div className="Send_maxButton">
                {decodedAmount === 0 ? <button onClick={() => { setAmount(parseInt(selectedSource.balance)) }}>Max</button> : <div></div>}
              </div>
              <input className="Send_amount_input" type="number" value={decodedAmount || amount} readOnly={decodedAmount !== 0} onChange={(e) => { setAmount(+e.target.value) }} />
              <button onClick={() => { setAmountAssets(amountAssets === "BTC" ? "sats" : "BTC") }}>{amountAssets}</button>
            </div>
          </div>
          <div className='Send_available_amount'>
            {!!satsPerByte && <div className='Send_available_amount_sats'>
              <input type='number' value={satsPerByte} onChange={e => setSatsPerByte(+e.target.value)} />
              sats per byte
            </div>}
            <p className='Send_available_amount_amount'>
              ~ ${amount === 0 ? 0 : (amount * price.buyPrice * (amountAssets === "BTC" ? 1 : 0.00000001)).toFixed(2)}
            </p>
          </div>
          <div className="Send_to">
            <p>To:</p>
            <input type="text" placeholder="Invoice, Bitcoin or Lightning Address, nPub, Email" value={to} onChange={(e) => { onChangeTo(e.target.value) }} />
          </div>
          <div className="Send_for">
            <p>For:</p>
            <input type="text" placeholder="Add a note" value={note} onChange={(e) => { setNote(e.target.value) }} />
          </div>
          <div className="Send_from">
            <p>Spend From:</p>
            <SpendFromDropdown values={spendSources} initialValue={spendSources[0]} callback={setSelectedSource} />
          </div>
        </div>
      </div>
      <div className="Send_other_options">
        <div className="Send_lnurl">
          <div className="Send_set_amount_copy">
            <button onClick={() => { router.push("/home") }}>{Icons.Close()}CANCEL</button>
          </div>
        </div>
        <div className="Send_chain">
          <div className="Send_set_amount_copy">
            <button onClick={handleSubmit}>{Icons.send()}SEND</button>
          </div>
        </div>
      </div>
      <Modal isShown={isShown} hide={toggle} modalContent={confirmContent} headerText={''} />
    </div>
  )
}