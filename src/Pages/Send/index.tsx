import React, { useEffect, useState } from 'react';
import { PageProps, SpendFrom } from "../../globalTypes";
import { nostr } from '../../Api'
import { notification } from 'antd';

//It import svg icons library
import * as Icons from "../../Assets/SvgIconLibrary";
import { AddressType } from '../../Api/autogenerated/ts/types';
import { UseModal } from '../../Hooks/UseModal';
import { useSelector, useDispatch } from 'react-redux';
import type { NotificationPlacement } from 'antd/es/notification/interface';
import axios from 'axios';
import { useIonRouter } from '@ionic/react';
import { Modal } from '../../Components/Modals/Modal';
import SpendFromDropdown from '../../Components/Dropdowns/SpendFromDropdown';

type PayInvoice = {
  type: 'payInvoice'
  invoice: string
  amount: number
}
type PayAddress = {
  type: 'payAddress'
  address: string
}

export const Send = () => {
  const price = useSelector((state: any) => state.usdToBTC);

  //reducer
  const spendSources = useSelector((state: any) => state.spendSource).map((e: any) => { return { ...e } });

  const [error, setError] = useState("")
  const [payOperation, setPayOperation] = useState<PayInvoice | PayAddress | null>(null)
  const [invoiceAmount, setInvoiceAmount] = useState(0);
  const [invoiceMemo, setInvoiceMemo] = useState("");
  const [deg, setDeg] = useState("rotate(0deg)");
  const [valueQR, setValueQR] = useState("LNURL12344adfasdfasdfasdfsdf5677888");
  const [vCreateInvoice, setVCreateInvoice] = useState(0);
  const [vReceive, setVReceive] = useState(1);
  const [isCopy, setIsCopy] = useState(false);
  const [amountAssets, setAmountAssets] = useState("sats");
  const [amount, setAmount] = useState("");
  const [to, setTo] = useState("");
  const [note, setNote] = useState("");
  const { isShown, toggle } = UseModal();
  const [amountToPay, setAmountToPay] = useState(0)

  const router = useIonRouter();

  const [api, contextHolder] = notification.useNotification();
  const openNotification = (placement: NotificationPlacement, header: string, text: string) => {
    api.info({
      message: header,
      description:
        text,
      placement
    });
  };

  useEffect(() => {
    if (spendSources.length === 0) {
      setTimeout(() => {
        router.push("/home");
      }, 1000);
      return openNotification("top", "Error", "You don't have any source!");
    }
  });

  const ChainAdress = async () => {
    const res = await nostr.NewAddress({ addressType: AddressType.WITNESS_PUBKEY_HASH })
    if (res.status !== 'OK') {
      setError(res.reason)
      return
    }

    setValueQR(`bitcoin:${res.address}`);
    setDeg("rotate(90deg)");
    setIsCopy(false);
  }

  const CreateInvoice = () => {
    setVCreateInvoice(1);
    setVReceive(0);
  }

  const CreateInvoiceOK = async () => {
    const res = await nostr.NewInvoice({
      amountSats: invoiceAmount,
      memo: invoiceMemo
    })
    if (res.status !== 'OK') {
      setError(res.reason)
      return
    }
    setVCreateInvoice(0);
    setVReceive(1);
    setDeg("rotate(180deg)");
    setValueQR(`lightning:${res.invoice}`);
    setIsCopy(false);
  }

  const CreateInvoiceCancel = () => {
    setVCreateInvoice(0);
    setVReceive(1);
  }

  const parse = async (input: string) => {
    console.log("parsing")
    setError("");
    const lowData = input.toLowerCase()
    if (lowData.startsWith('pub_product:')) {
      console.log("parsed pub product", lowData)
      const productData = JSON.parse(lowData.slice('pub_product:'.length))
      const productId = productData.productId

      console.log("send the buy request to the following pub:", productData.dest)
      console.log("send the buy request using the following relays:", productData.relays)

      const invoiceRes = await nostr.NewProductInvoice({ id: productId })
      if (invoiceRes.status !== 'OK') {
        setError(invoiceRes.reason)
        return
      }
      const decodedRes = await nostr.DecodeInvoice({ invoice: invoiceRes.invoice })
      if (decodedRes.status !== 'OK') {
        setError(decodedRes.reason)
        return
      }
      setPayOperation({
        type: 'payInvoice',
        invoice: invoiceRes.invoice,
        amount: decodedRes.amount
      })
    } else if (lowData.startsWith('bitcoin:')) {
      const btcAddress = lowData.slice('bitcoin:'.length)
      setPayOperation({
        type: 'payAddress',
        address: btcAddress
      })
    } else if (lowData.startsWith('lightning:')) {
      const lnOperation = lowData.slice('lightning:'.length)
      if (lnOperation.startsWith("lnurl")) {
        setError("lnurl not supported yet" + lnOperation)
      } else {
        const res = await nostr.DecodeInvoice({ invoice: lnOperation })
        console.log(res);

        if (res.status !== 'OK') {
          setError(res.reason)
          return
        }
        setPayOperation({
          type: 'payInvoice',
          invoice: lnOperation,
          amount: res.amount
        })

      }
    } else {
      setError("scanned content unsupported " + lowData)
    }
  }

  const pay = async (action: PayInvoice | PayAddress) => {
    switch (action.type) {
      case 'payAddress':
        const resA = await nostr.PayAddress({
          address: action.address,
          amoutSats: +amount,
          satsPerVByte: 10
        })
        if (resA.status !== 'OK') {
          setError(resA.reason)
          return
        }
        router.push("/home")
        break;
      case 'payInvoice':
        const resI = await nostr.PayInvoice({
          invoice: action.invoice,
          amount: 0,
        })
        if (resI.status !== 'OK') {
          setError(resI.reason)
          return
        }
        router.push("/home")
        break;
    }
  }

  const handleSubmit = async () => {
    console.log(to);
  }

  const confirmContent = <React.Fragment>
    <div className="Sources_notify">
      <div className="Sources_notify_title">Amount to Receive</div>
      <button className="Sources_notify_button" onClick={toggle}>OK</button>
    </div>
  </React.Fragment>;

  return (
    <div className='Send_container'>
      {contextHolder}
      <div className="Send" style={{ opacity: vReceive, zIndex: vReceive ? 1000 : -1 }}>
        <div className="Send_header_text">Send Payment</div>
        <div className="Send_config">
          <div className="Send_amount">
            Amount:
            <div className='Send_amount_container'>
              <input className="Send_amount_input" type="number" value={amount} onChange={(e) => { setAmount(e.target.value) }} />
              <button onClick={() => { setAmountAssets(amountAssets === "BTC" ? "sats" : "BTC") }}>{amountAssets}</button>
            </div>
          </div>
          <div className='Send_available_amount'>
            ~ ${parseInt(amount === "" ? "0" : amount) === 0 ? 0 : (parseInt(amount === "" ? "0" : amount) * price.buyPrice * (amountAssets === "BTC" ? 1 : 0.00000001)).toFixed(2)}
          </div>
          <div className="Send_to">
            <p>To:</p>
            <input type="text" placeholder="Invoice, Bitcoin or Lightning Address, nPub, Email" value={to} onChange={(e) => { setTo(e.target.value) }} />
          </div>
          <div className="Send_for">
            <p>For:</p>
            <input type="text" placeholder="Add a note" value={note} onChange={(e) => { setNote(e.target.value) }} />
          </div>
          <div className="Send_from">
            <p>Spend From:</p>
            <SpendFromDropdown values={spendSources} initialValue={spendSources[0]} />
          </div>
        </div>
      </div>
      <div className="Send_other_options">
        <div className="Send_lnurl">
          <div className="Send_set_amount_copy">
            <button onClick={() => { router.goBack() }}>{Icons.Close()}CANCEL</button>
          </div>
        </div>
        <div className="Send_chain">
          <div className="Send_set_amount_copy">
            <button onClick={handleSubmit}>{Icons.send()}SEND</button>
          </div>
        </div>
      </div>
      <Modal isShown={isShown} hide={toggle} modalContent={confirmContent} headerText={''} />
    </div>
  )
}