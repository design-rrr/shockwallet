import { useCallback, useEffect, useLayoutEffect, useMemo, useState } from "react";
import { selectNostrSpends, useDispatch, useSelector } from "../../State/store";
import { getNostrClient, parseNprofile } from "../../Api/nostr";
import { DebitAuthorization, DebitRule_rule_type, } from "../../Api/pub/autogenerated/ts/types";
import { SpendFrom } from "../../globalTypes";
import { getDebitAppNameAndAvatarUrl } from "../../Components/Modals/DebitRequestModal/helpers";
import { NOSTR_RELAYS } from "../../constants";
import { nip19 } from "nostr-tools";
import moment from "moment";
import SpendFromDropdown from "../../Components/Dropdowns/SpendFromDropdown";
import { Clipboard } from "@capacitor/clipboard";
import { toast } from "react-toastify";
import styles from "./styles/index.module.scss";
import Spinner from "../../Components/Spinner";
import classNames from "classnames";
import { EditSource } from "../../Assets/SvgIconLibrary";
import { setDebitToEdit } from "../../State/Slices/modalsSlice";
import Checkbox from "../../Components/Checkbox";
import { formatNumberWithCommas } from "../../utils/numbers";
import { useIonRouter } from "@ionic/react";
import Toast from "../../Components/Toast";

type StateDebitAuth = DebitAuthorization & { source: SpendFrom, domainName?: string, avatarUrl?: string }

export const LinkedApp = () => {
  const dispatch = useDispatch();
  const router = useIonRouter()
  const [debitAuthorizations, setDebitAuthorizations] = useState<{
    debitAuths: StateDebitAuth[],
    debitAuthsBanned: StateDebitAuth[]
  }>({
    debitAuths: [],
    debitAuthsBanned: []
  })
  const nodedUp = useSelector(state => state.nostrPrivateKey);
  const nostrSpends = useSelector(selectNostrSpends);
  const paySources = useSelector(state => state.paySource)
  const refetchHook = useSelector(state => state.modalsSlice.debitsRefetchHook);

  const [selectedSource, setSelectedSource] = useState(nostrSpends[0]);
  const [hasNoDebits, setHasNoDebits] = useState(false)

  const [isPubliclyAvailable, setIsPubliclyAvailable] = useState(false);

  const [isShowingBans, setIsShowingBans] = useState(false);

  useLayoutEffect(() => {
    if (nostrSpends.length === 0) {
      toast.error(<Toast title="Error" message="You don't have any spend sources." />)
      router.push("/home");
    }
    setSelectedSource(nostrSpends[0]);
  }, [nostrSpends, router]);


  const fetchAuths = useCallback(() => {
    const { pubkey, relays } = parseNprofile(selectedSource.pasteField)
    getNostrClient({ pubkey, relays }, selectedSource.keys).then(c => {
      c.GetDebitAuthorizations().then(res => {
        if (res.status === "OK") {
          if (res.debits.length === 0) {
            setHasNoDebits(true);
          } else {
            setDebitAuthorizations({
              debitAuths: res.debits.filter(d => d.authorized).map(debit => ({ ...debit, source: selectedSource })),
              debitAuthsBanned: res.debits.filter(d => !d.authorized).map(debit => ({ ...debit, source: selectedSource }))
            })
          }

        }
      })
    })
  }, [selectedSource])

  useEffect(() => {
    if (!nodedUp) {
      return;
    }
    setDebitAuthorizations({ debitAuths: [], debitAuthsBanned: [] })
    setHasNoDebits(false);
    fetchAuths()
  }, [fetchAuths, nodedUp, refetchHook])



  const cardsToRender = useMemo(() => {
    const debitsToShow: StateDebitAuth[] = isShowingBans ? debitAuthorizations.debitAuthsBanned : debitAuthorizations.debitAuths
    return debitsToShow.map((debitAuth, index) => {
      console.log({debitAuth})
      const npub = nip19.npubEncode(debitAuth.npub);
      const substringedNpub = `${npub.substring(0, 20)}...${npub.substring(npub.length - 20, npub.length)}`;

      if (!debitAuth.avatarUrl) {

        getDebitAppNameAndAvatarUrl(debitAuth.npub, parseNprofile(debitAuth.source.pasteField).relays || NOSTR_RELAYS).then(({ requestorDomain, avatarUrl }) => {
          console.log({avatarUrl})
          setDebitAuthorizations(state => {
            if (isShowingBans) {
              return {
                ...state,
                debitAuthsBanned: state.debitAuthsBanned.map((item, i) =>
                  i === index ? { ...debitAuth, domainName: requestorDomain, avatarUrl } : item
                )
              }
            } else {
              return {
                ...state,
                debitAuths: state.debitAuths.map((item, i) =>
                  i === index ? { ...debitAuth, domainName: requestorDomain, avatarUrl } : item
                )
              }
            }
          });
        })
      }

      return (
        <div key={debitAuth.debit_id} className={styles["app-card"]}>
          <div className={styles.left}>
            <img src={debitAuth.avatarUrl} />
          </div>
          <div className={styles["right"]}>
            {
              debitAuth.domainName
              ?
              <span className={styles["name"]}>
                {debitAuth.domainName}
              </span>
              :
              <span className={classNames(styles["name"], styles["unknown-app"])}>
                Unknown App
              </span>
            }
            <span className={styles["npub"]}>
              {substringedNpub}
            </span>
            <div className={styles["rules"]}>
              {
                debitAuth.rules.map((rule, i) => {
                  if (rule.rule.type === DebitRule_rule_type.FREQUENCY_RULE) {
                    return <span key={i}><span className={styles["blue-text"]}>{formatNumberWithCommas(rule.rule.frequency_rule.amount.toString())} sats</span> per {rule.rule.frequency_rule.interval}</span>
                  } else {
                    return <span key={i}><span>Expires {moment(rule.rule.expiration_rule.expires_at_unix).fromNow()}</span></span>
                  }
                })
              }
            </div>
            {/* <div className={styles["reset"]} onClick={() => resetAuth({ source: debitAuth.source, npub: debitAuth.npub })}>
              Reset
            </div> */}
            <div className={styles["edit-icon"]} onClick={() => {
              dispatch(setDebitToEdit({ ...debitAuth, sourceId: debitAuth.source.id }))
            }}>
              <EditSource />
            </div>
          </div>

        </div>
      )
    })
  }, [debitAuthorizations, dispatch, isShowingBans])

  const counterpartPaySource = paySources.sources[selectedSource.id] || null;

  return (
    <div className={styles["wrapper"]}>
      <div className={styles["container"]}>

        <div className={styles["page-header"]}>Linked Apps</div>
        <div className={styles["source-selection"]}>
          <SpendFromDropdown values={nostrSpends} value={selectedSource} callback={setSelectedSource} />
        </div>
        <div className={styles["list-scroller"]}>

          {
            (debitAuthorizations.debitAuths.length > 0 || debitAuthorizations.debitAuthsBanned.length > 0)
            ?
            cardsToRender
            :
              hasNoDebits
              ?
              <div className={styles["spinner-container"]}>This source has no debits yet.</div>
              :
              <div className={styles["spinner-container"]}>
                <Spinner />
              </div>
          }
        </div>
        <div style={{ padding: "0 12px" }}>
          <div className={classNames(styles["app-card"], styles["column"])}>
            <span className={styles["title"]}>My debit string:</span>
            <span className={styles["debit-string"]} onClick={async () => {
              await Clipboard.write({ string: selectedSource.ndebit })
              toast.success("Copied to clipboard.")
            }}>
              {selectedSource.ndebit}
            </span>
            {
              (counterpartPaySource && counterpartPaySource.vanityName)
              &&
              <>
                <div className={styles["checkbox-container"]} style={{ marginTop: "12px" }}>
                  <span className={styles["label"]}>Make publicly disoverable via Lightning Address:</span>
                  <Checkbox id="publicly-available" state={isPubliclyAvailable} setState={(e) => setIsPubliclyAvailable(e.target.checked)} />
                </div>
                <div className={styles["checkbox-container"]}>
                  <span className={styles["ln-address"]}>&#40;{ counterpartPaySource.vanityName }&#41;</span>
                </div>
              </>
            }
          </div>
        </div>
        <div className={styles["change-view-button-container"]}>
          <div onClick={() => setIsShowingBans(!isShowingBans)}>
            {
              isShowingBans
              ?
              <span >&lt; Back to approved list </span>
              :
              <span> View ban list &gt;</span>
            }
          </div>
        </div>
      </div>
    </div>
  );
};


