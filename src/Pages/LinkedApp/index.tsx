import { useCallback, useEffect, useLayoutEffect, useMemo, useState } from "react";
import { useDispatch, useSelector } from "../../State/store/store";
import { getNostrClient } from "../../Api/nostr";
import { DebitAuthorization, DebitRule_rule_type, } from "../../Api/pub/autogenerated/ts/types";
import { getDebitAppNameAndAvatarUrl } from "../../Components/Modals/DebitRequestModal/helpers";
import { getDeviceId, NOSTR_RELAYS } from "../../constants";
import { nip19 } from "nostr-tools";
import moment from "moment";
import { Clipboard } from "@capacitor/clipboard";
import { toast } from "react-toastify";
import styles from "./styles/index.module.scss";
import classNames from "classnames";
import { EditSource } from "../../Assets/SvgIconLibrary";
import { setDebitToEdit } from "../../State/Slices/modalsSlice";
import Checkbox from "../../Components/Checkbox";
import { IonAvatar, IonLabel, IonNote, useIonRouter } from "@ionic/react";
import Toast from "../../Components/Toast";
import { useAppSelector } from "@/State/store/hooks";
import { NprofileView, selectHealthyNprofileViews } from "@/State/scoped/backups/sources/selectors";
import { sourcesActions } from "@/State/scoped/backups/sources/slice";
import { CustomSelect } from "@/Components/CustomSelect";

type StateDebitAuth = DebitAuthorization & { source: NprofileView, domainName?: string, avatarUrl?: string }

const LinkedApp = () => {
	const dispatch = useDispatch();
	const router = useIonRouter()
	const [debitAuthorizations, setDebitAuthorizations] = useState<{
		debitAuths: StateDebitAuth[],
		debitAuthsBanned: StateDebitAuth[]
	}>({
		debitAuths: [],
		debitAuthsBanned: []
	})
	const nodedUp = useSelector(state => state.appState.bootstrapped);
	const healthyNprofileSourceViews = useAppSelector(selectHealthyNprofileViews);


	const refetchHook = useSelector(state => state.modalsSlice.debitsRefetchHook);

	const [selectedSource, setSelectedSource] = useState(healthyNprofileSourceViews[0]);
	const [_hasNoDebits, setHasNoDebits] = useState(false)

	const [isPubliclyAvailable, setIsPubliclyAvailable] = useState(selectedSource?.isNDebitDiscoverable || false);

	const [lnAddress, setLnAddress] = useState("")

	const [isShowingBans, setIsShowingBans] = useState(false);

	useLayoutEffect(() => {
		if (healthyNprofileSourceViews.length === 0) {
			toast.error(<Toast title="Error" message="You don't have any spend sources." />)
			router.push("/home");
		}
		setSelectedSource(healthyNprofileSourceViews[0]);
	}, [healthyNprofileSourceViews, router]);




	const fetchAuths = useCallback(() => {
		if (!selectedSource) return;


		setLnAddress(selectedSource.vanityName || "")
		setIsPubliclyAvailable(!!selectedSource.isNDebitDiscoverable)

		getNostrClient({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys).then(c => {
			c.GetDebitAuthorizations().then(res => {
				if (res.status === "OK") {
					if (res.debits.length === 0) {
						setHasNoDebits(true);
					} else {
						setDebitAuthorizations({
							debitAuths: res.debits.filter(d => d.authorized).map(debit => ({ ...debit, source: selectedSource })),
							debitAuthsBanned: res.debits.filter(d => !d.authorized).map(debit => ({ ...debit, source: selectedSource }))
						})
					}

				}
			})
		})
	}, [selectedSource])

	useEffect(() => {
		if (!nodedUp) {
			return;
		}
		setDebitAuthorizations({ debitAuths: [], debitAuthsBanned: [] })
		setHasNoDebits(false);
		fetchAuths()
	}, [fetchAuths, nodedUp, refetchHook])



	const cardsToRender = useMemo(() => {
		const debitsToShow: StateDebitAuth[] = isShowingBans ? debitAuthorizations.debitAuthsBanned : debitAuthorizations.debitAuths
		return debitsToShow.map((debitAuth, index) => {
			const npub = nip19.npubEncode(debitAuth.npub);
			const substringedNpub = `${npub.substring(0, 20)}...${npub.substring(npub.length - 20, npub.length)}`;

			if (!debitAuth.avatarUrl) {

				getDebitAppNameAndAvatarUrl(debitAuth.npub, debitAuth.source.relays || NOSTR_RELAYS).then(({ requestorDomain, avatarUrl }) => {
					console.log({ avatarUrl })
					setDebitAuthorizations(state => {
						if (isShowingBans) {
							return {
								...state,
								debitAuthsBanned: state.debitAuthsBanned.map((item, i) =>
									i === index ? { ...debitAuth, domainName: requestorDomain, avatarUrl } : item
								)
							}
						} else {
							return {
								...state,
								debitAuths: state.debitAuths.map((item, i) =>
									i === index ? { ...debitAuth, domainName: requestorDomain, avatarUrl } : item
								)
							}
						}
					});
				})
			}

			return (
				<div key={debitAuth.debit_id} className={styles["app-card"]}>
					<div className={styles.left}>
						<img src={debitAuth.avatarUrl} />
					</div>
					<div className={styles["right"]}>
						{
							debitAuth.domainName
								?
								<span className={styles["name"]}>
									{debitAuth.domainName}
								</span>
								:
								<span className={classNames(styles["name"], styles["unknown-app"])}>
									Unknown App
								</span>
						}
						<span className={styles["npub"]}>
							{substringedNpub}
						</span>
						<div className={styles["rules"]}>
							{
								debitAuth.rules.map((rule, i) => {
									if (rule.rule.type === DebitRule_rule_type.FREQUENCY_RULE) {
										return <span key={i}><span className={styles["blue-text"]}>{rule.rule.frequency_rule.amount.toLocaleString()} sats</span> per {rule.rule.frequency_rule.interval}</span>
									} else {
										return <span key={i}><span>Expires {moment(rule.rule.expiration_rule.expires_at_unix).fromNow()}</span></span>
									}
								})
							}
						</div>
						{/* <div className={styles["reset"]} onClick={() => resetAuth({ source: debitAuth.source, npub: debitAuth.npub })}>
              Reset
            </div> */}
						<div className={styles["edit-icon"]} onClick={() => {
							dispatch(setDebitToEdit({ ...debitAuth, sourceId: debitAuth.source.sourceId }))
						}}>
							<EditSource />
						</div>
					</div>

				</div>
			)
		})
	}, [debitAuthorizations, dispatch, isShowingBans])



	const handleFlipPubliclyDiscoverable = (checked: boolean) => {
		if (!selectedSource) return;
		const deviceId = getDeviceId();

		dispatch(sourcesActions.updateisNDebitDiscoverable({ sourceId: selectedSource.sourceId, isNdebitDiscoverable: checked, by: deviceId, now: Date.now() }));
		setIsPubliclyAvailable(checked)

	}

	return (
		<div className={styles["wrapper"]} key={selectedSource.sourceId}>
			<div className={styles["container"]}>

				<div className={styles["page-header"]}>Linked Apps</div>
				<div className={styles["source-selection"]}>
					<CustomSelect<NprofileView>
						items={healthyNprofileSourceViews}
						selectedItem={selectedSource}
						onSelect={setSelectedSource}
						getIndex={(source) => source.sourceId}
						title="Select Source"
						subTitle="Select a source to view its nbedit rules"
						renderItem={(source) => {
							return (
								<>
									<IonAvatar slot="start">
										<img src={`https://robohash.org/${source.sourceId}.png?bgset=bg1`} alt='Avatar' />
									</IonAvatar>
									<IonLabel style={{ width: "100%" }}>
										<h2>{source.label}</h2>
										<IonNote className="ion-text-no-wrap text-low" style={{ display: "block" }}>
											Lightning.Pub Source
										</IonNote>
									</IonLabel>
								</>
							)
						}}
						renderSelected={(source) => (
							<>
								<IonAvatar slot="start">
									<img src={`https://robohash.org/${source.sourceId}.png?bgset=bg1`} alt='Avatar' />
								</IonAvatar>
								<IonLabel>
									{source?.label || ''}
								</IonLabel>
							</>
						)}
					>
					</CustomSelect>
				</div>
				<div className={styles["list-scroller"]}>

					{
						(debitAuthorizations.debitAuths.length > 0 || debitAuthorizations.debitAuthsBanned.length > 0) ? (
							cardsToRender
						) : (
							<div style={{
								marginTop: '40px',
								fontSize: '18px',
								color: '#a3a3a3',
								width: '100%',
								textAlign: 'center'
							}}>
								<span>Approval rules will be listed here.</span>
							</div>
						)
					}
				</div>
				<div style={{ width: '100%' }}>
					<div
						className={classNames(styles["app-card"], styles["column"])}
						style={{
							fontSize: '1.2rem',
							width: '100%',
							marginBottom: '5px',
							borderRadius: '5px',
							border: '1px solid #2a3035',
							boxShadow: '0px 0px 2px rgba(0, 0, 0, 1)',
							backgroundColor: '#16191c',
							padding: '10px'
						}}
					>
						<span className={styles["title"]}>My debit string:</span>
						<span
							className={styles["debit-string"]}
							onClick={async () => {
								await Clipboard.write({ string: selectedSource.ndebit })
								toast.success("Copied to clipboard.")
							}}
						>
							{selectedSource.ndebit}
						</span>
						{
							lnAddress
							&&
							<>
								<div className={styles["checkbox-container"]} style={{ marginTop: "12px" }}>
									<span className={styles["label"]}>Make publicly discoverable via Lightning Address:</span>
									<Checkbox id="publicly-available" state={isPubliclyAvailable} setState={(e) => handleFlipPubliclyDiscoverable(e.target.checked)} />
								</div>
								<div className={styles["checkbox-container"]}>
									<span className={styles["ln-address"]}>&#40;{lnAddress}&#41;</span>
								</div>
							</>
						}
					</div>
				</div>
				<div className={styles["change-view-button-container"]}>
					<div onClick={() => setIsShowingBans(!isShowingBans)}>
						{
							isShowingBans
								?
								<span >&lt; Back to approved list </span>
								:
								<span> View ban list &gt;</span>
						}
					</div>
				</div>
			</div>
		</div>
	);
};

export default LinkedApp;
