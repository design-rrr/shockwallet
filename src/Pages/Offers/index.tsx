import { useCallback, useEffect, useState } from "react";
import {
	IonAvatar,
	IonCol,
	IonContent,
	IonFab,
	IonFabButton,
	IonGrid,
	IonHeader,
	IonIcon,
	IonLabel,
	IonList,
	IonNote,
	IonPage,
	IonRow,
	IonToolbar,
	useIonToast
} from "@ionic/react";
import BackToolbar from "@/Layout2/BackToolbar";
import { CustomSelect } from "@/Components/CustomSelect";
import OfferItem from "@/Components/OfferItem";
import { add } from "ionicons/icons";
import type { OfferConfig, OfferInvoice } from "@/Api/pub/autogenerated/ts/types";
import OfferInfoModal from "@/Components/Modals/OfferInfoModal";
import { addUserOffer, deleteUserOffer, getUserOffer, getUserOfferInvoices, getUserOffers, updateUserOffer } from "@/lib/noffer";
import FullSpinner from "@/Components/common/ui/fullSpinner";
import EmptyState from "@/Components/common/ui/emptyState";
import { useAppSelector } from "@/State/store/hooks";
import { NprofileView, selectHealthyNprofileViews } from "@/State/scoped/backups/sources/selectors";
import { selectFavoriteSourceId } from "@/State/scoped/backups/identity/slice";
import HomeHeader from "@/Layout2/HomeHeader";


const Offers = () => {
	const [present] = useIonToast();
	const healthyNprofileSourceViews = useAppSelector(selectHealthyNprofileViews);
	const favoriteSourceId = useAppSelector(selectFavoriteSourceId);
	const [selectedSource, setSelectedSource] = useState<NprofileView>(() => {
		const favIsNprofile = healthyNprofileSourceViews.find(s => s.sourceId === favoriteSourceId);
		if (favIsNprofile) {
			return favIsNprofile
		}

		const withBalance = healthyNprofileSourceViews.find(s => s.maxWithdrawableSats || 0 > 0);
		if (withBalance) return withBalance;

		if (healthyNprofileSourceViews.length === 0) {
			throw new Error("No healthyNprofileViews available");
		}
		return healthyNprofileSourceViews[0];
	});



	const [modalOpen, setModalOpen] = useState(false);

	const [sourceOffers, setSourceOffers] = useState<OfferConfig[]>([]);
	const [selectedOffer, setSelectedOffer] = useState<OfferConfig | undefined>(undefined);
	const [isLoading, setIsLoading] = useState(true);

	const openForNew = () => { setSelectedOffer(undefined); setModalOpen(true); };
	const openForExisting = (offer: OfferConfig) => { setSelectedOffer(offer); setModalOpen(true); };


	useEffect(() => {
		const getOffers = async () => {
			setIsLoading(true);
			setSourceOffers([]);
			try {
				const offers = await getUserOffers({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys);
				setSourceOffers(offers || []);
			} catch (err: any) {
				present({
					message: err?.message || "Failed to fetch offers",
					color: "danger",
					duration: 5000
				});
			}
			setIsLoading(false);
		}

		getOffers();
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [selectedSource]);


	const onSave = useCallback(async (offer: OfferConfig, isNew: boolean) => {
		try {
			if (isNew) {
				const newOfferId = await addUserOffer({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys, offer);
				const newOffer = await getUserOffer({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys, newOfferId);
				setSourceOffers(prevOffers => [...prevOffers, { ...newOffer }]);
			} else {
				await updateUserOffer({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys, offer);
				const refetched = await getUserOffer({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys, offer.offer_id);

				setSourceOffers(prevOffers => prevOffers.map(o => o.offer_id === offer.offer_id ? refetched : o));
			}
			present({
				message: "Offer saved successfully",
				color: "success",
				duration: 5000
			})
		} catch (err: any) {
			present({
				message: err?.message || "Failed to save offer",
				color: "danger",
				duration: 5000
			})
		}
		setModalOpen(false);
	}, [selectedSource, present])


	const fetchOfferInvoices = useCallback(async (offerId: string): Promise<OfferInvoice[] | null> => {
		try {
			const offerInvoices = await getUserOfferInvoices({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys, offerId);
			return offerInvoices;
		} catch (err: any) {
			present({
				message: err?.message || "Failed to fetch offer invoice",
				color: "danger",
				duration: 5000
			});
			return null;
		}
	}, [present, selectedSource]);

	const deleteOffer = useCallback(async (offerId: string) => {
		try {
			await deleteUserOffer({ pubkey: selectedSource.lpk, relays: selectedSource.relays }, selectedSource.keys, offerId);
			setSourceOffers(prevOffers => prevOffers.filter(o => o.offer_id !== offerId));
			present({
				message: "Offer deleted successfully",
				color: "success",
				duration: 5000
			});
		} catch (err: any) {
			present({
				message: err?.message || "Failed to delete user Offer",
				color: "danger",
				duration: 5000
			})
		}
	}, [present, selectedSource])

	return (
		<IonPage className="ion-page-width">
			<IonHeader className="ion-no-border">
				<HomeHeader />
				<IonToolbar className="ion-padding-horizontal ion-padding-bottom">
					<CustomSelect<NprofileView>
						items={healthyNprofileSourceViews}
						selectedItem={selectedSource}
						onSelect={setSelectedSource}
						getIndex={(source) => source.sourceId}
						title="Select Source"
						subTitle="Select the source you want to spend from"
						renderItem={(source) => {
							return (
								<>
									<IonAvatar slot="start">
										<img src={`https://robohash.org/${source.sourceId}.png?bgset=bg1`} alt='Avatar' />
									</IonAvatar>
									<IonLabel style={{ width: "100%" }}>
										<h2>{source.label}</h2>
										<IonNote className="ion-text-no-wrap text-low" style={{ display: "block" }}>
											Lightning.Pub Source
										</IonNote>
									</IonLabel>
								</>
							)
						}}
						renderSelected={(source) => (
							<>
								<IonAvatar slot="start">
									<img src={`https://robohash.org/${source.sourceId}.png?bgset=bg1`} alt='Avatar' />
								</IonAvatar>
								<IonLabel>
									{source?.label || ''}
								</IonLabel>
							</>
						)}
					>
					</CustomSelect>

				</IonToolbar>
			</IonHeader>
			<IonContent className="ion-padding" fullscreen>
				{
					isLoading ? (
						<FullSpinner />
					) : sourceOffers.length > 0 ? (
						<IonGrid>
							<IonRow className="ion-margin-top">
								<IonCol>
									<IonList lines="none">
										{
											sourceOffers.map((offer, i) => (
												<OfferItem
													key={i}
													offer={({ ...offer, sourceId: selectedSource.sourceId })}
													handleSelectOffer={openForExisting}
													onDelete={deleteOffer}
												/>
											))
										}
									</IonList>
								</IonCol>
							</IonRow>
						</IonGrid>
					) : (
						<div style={{ height: "80%", width: "100%" }}>
							<EmptyState message="The selected source has no offers yet" />
						</div>
					)
				}
				<IonFab slot="fixed" vertical="bottom" horizontal="end">
					<IonFabButton onClick={openForNew}>
						<IonIcon icon={add}></IonIcon>
					</IonFabButton>
				</IonFab>
				<OfferInfoModal
					isOpen={modalOpen}
					onClose={() => setModalOpen(false)}
					onSave={onSave}
					initialOffer={selectedOffer}
					fetchOfferInvoice={fetchOfferInvoices}
				/>
			</IonContent>
		</IonPage>
	);
};

export default Offers;
