import { generatePrivateKey, getPublicKey, nip19 } from 'nostr-tools'
import { NOSTR_PRIVATE_KEY_STORAGE_KEY, makeId } from '../constants'
import { NostrRequest } from './autogenerated/ts/nostr_transport'
import NewNostrClient from './autogenerated/ts/nostr_client'
import NostrHandler from './nostrHandler'
import { ProfilePointer } from 'nostr-tools/lib/nip19'
//import { Nip46Request, Nip46Response, serializeNip46Event } from './nip46'
export const setNostrPrivateKey = (nsec?: string) => {
    const key = nsec ? nsec : generatePrivateKey()
    localStorage.setItem(NOSTR_PRIVATE_KEY_STORAGE_KEY, key)
}
export const getNostrPrivateKey = () => {
    return localStorage.getItem(NOSTR_PRIVATE_KEY_STORAGE_KEY)
}

/*
export const setNip46PrivateKey = (nsec?: string) => {
    const key = nsec ? nsec : generatePrivateKey()
    localStorage.setItem(NIP46_PRIVATE_KEY_STORAGE_KEY, key)
}
export const getNip46PrivateKey = () => {
    return localStorage.getItem(NIP46_PRIVATE_KEY_STORAGE_KEY)
}
*/
export type nostrCallback<T> = { startedAtMillis: number, type: 'single' | 'stream', f: (res: T) => void }
export type Client = ReturnType<typeof NewNostrClient>
type PendingClient = { type: 'promise', queue: ((c: Client) => void)[] }
type ReadyClient = { type: 'client', client: Client }
type StoredClient = PendingClient | ReadyClient


export class ClientsCluster {
    clients: Record<string, NostrClient> = {}
    GetNostrClient = async (nProfile: { pubkey: string, relays?: string[] } | string): Promise<Client> => {
        const { pubkey, relays } = typeof nProfile === 'string' ? parseNprofile(nProfile) : nProfile

        if (!this.clients[pubkey]) {
            this.clients[pubkey] = new NostrClient(pubkey, relays ? relays : [])
        }
        const c = this.clients[pubkey]
        console.log("getting client:", c.getId())
        return c.Get()
    }

    GetAllNostrClients = () => {
        return Object.entries(this.clients).filter(([_, c]) => c.ready()).map(([pubkey, c]) => ({ pubkey, wrapper: c }))
    }
}

export class NostrClient {
    clientId = makeId(16)
    client: StoredClient = { type: 'promise', queue: [] }
    handler?: NostrHandler
    clientCbs: Record<string, nostrCallback<any>> = {}
    pubDestination: string
    clientPubKey: string
    latestResponseAtMillis = 0
    latestHelthReqAtMillis = 0

    constructor(pubDestination: string, relays: string[]) {
        this.pubDestination = pubDestination
        const privateKey = getNostrPrivateKey()
        if (!privateKey) {
            throw new Error("client not initialized correctly")
        }
        this.clientPubKey = getPublicKey(privateKey)
        const h = new NostrHandler({
            privateKey,
            publicKey: this.clientPubKey,
            relays
        },
            () => { this.onConnect(h) },
            e => {
                const res = JSON.parse(e.content) as { requestId: string }
                if (this.clientCbs[res.requestId]) {
                    const cb = this.clientCbs[res.requestId]

                    cb.f(res)
                    if (cb.type === 'single') {
                        delete this.clientCbs[res.requestId]
                        console.log(this.getSingleSubs(), "single subs left")
                    }
                } else {
                    console.log("cb not found for", res)
                }
            }, () => { this.disconnectCalls("relay disconnected") })
    }

    getId = () => {
        return this.clientId
    }

    Get = async () => {
        if (this.client.type === 'client') {
            return this.client.client
        }
        return new Promise<Client>((res) => {
            (this.client as PendingClient).queue.push(res)
        })
    }

    ready = () => {
        return this.client.type === 'client'
    }



    onConnect = (handler: NostrHandler) => {
        if (this.client.type === 'promise') {
            const client = this.wrapClientAroundHandler(handler)
            this.client.queue.forEach(f => f(client))
        }
    }

    wrapClientAroundHandler = (handler: NostrHandler) => {
        this.handler = handler
        const readyClient = NewNostrClient({
            retrieveNostrUserAuth: async () => { return this.clientPubKey },
            pubDestination: this.pubDestination,
        }, this.clientSend, this.clientSub)
        this.client = { type: 'client', client: readyClient }
        return readyClient
    }

    getClientState = () => {
        return {
            latestResponseAtMillis: this.latestResponseAtMillis,
            latestHelthReqAtMillis: this.latestHelthReqAtMillis,
        }
    }

    sendHelthRequest = () => {
        if (this.client.type !== 'client') {
            throw new Error("client not ready")
        }
        this.latestHelthReqAtMillis = Date.now()
        this.client.client.UserHealth()
    }

    getSingleSubs = () => {
        return Object.entries(this.clientCbs).filter(([_, cb]) => cb.type === 'single')
    }

    getHandler = () => {
        if (!this.handler) {
            throw new Error("handler not initialized")
        }
        return this.handler
    }

    clientSend = (to: string, message: NostrRequest): Promise<any> => {
        if (!message.requestId) {
            message.requestId = makeId(16)
        }
        const reqId = message.requestId
        if (this.clientCbs[reqId]) {
            throw new Error("request was already sent")
        }
        this.getHandler().Send(to, JSON.stringify(message))

        console.log("subbing  to single send", reqId)
        return new Promise(res => {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'single',
                f: (response: any) => { this.latestResponseAtMillis = Date.now(); res(response) },
            }
        })
    }
    clientSub = (to: string, message: NostrRequest, cb: (res: any) => void): void => {
        if (!message.requestId) {
            message.requestId = message.rpcName
        }
        const reqId = message.requestId
        if (!reqId) {
            throw new Error("invalid sub")
        }
        if (this.clientCbs[reqId]) {
            this.clientCbs[reqId] = {
                startedAtMillis: Date.now(),
                type: 'stream',
                f: (response: any) => { this.latestResponseAtMillis = Date.now(); cb(response) },
            }
            console.log("sub for", reqId, "was already registered, overriding")
            return
        }
        this.getHandler().Send(to, JSON.stringify(message))
        console.log("subbing  to stream", reqId)
        this.clientCbs[reqId] = {
            startedAtMillis: Date.now(),
            type: 'stream',
            f: (response: any) => { this.latestResponseAtMillis = Date.now(); cb(response) }
        }
    }

    disconnectCalls = (reason?: string) => {
        for (const key in this.clientCbs) {
            const element = this.clientCbs[key]
            element.f({ status: "ERROR", reason: reason ? reason : "nostr connection timeout" })
            delete this.clientCbs[key]
        }
        this.latestResponseAtMillis = 0
        this.latestHelthReqAtMillis = 0
    }
}



const cluster: ClientsCluster = new ClientsCluster()

export const getNostrClient = async (nProfile: { pubkey: string, relays?: string[] } | string): Promise<Client> => {
    return cluster.GetNostrClient(nProfile)
}

export const getAllNostrClients = () => {
    return cluster.GetAllNostrClients()
}

export const parseNprofile = (nprofile: string) => {
    const { type, data } = nip19.decode(nprofile)
    if (type !== "nprofile") {
        throw new Error("invalid bech32 this is not a nprofile")
    }
    const dataString = JSON.stringify(data);
    const dataBox = JSON.parse(dataString);

    return dataBox as ProfilePointer;
}
