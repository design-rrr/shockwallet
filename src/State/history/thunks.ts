import { AnyAction, ThunkAction } from '@reduxjs/toolkit';
import { parseOperationsResponse, payInvoiceReponseToSourceOperation, populateCursorRequest, userOperationToSourceOperation, } from './helpers';
import { addNewOperation, addOptimisticOperation, removeOptimisticOperation, updateOptimsticOperation, } from '.';
import { AppDispatch, selectNostrSpends, State } from '../store';
import { getNostrClient } from '../../Api';
import { UserOperation } from '../../Api/pub/autogenerated/ts/types';
import { SourceActualOperation, SourceOperationInvoice, SourceOptimsiticInvoice, SourceOptimsiticOnChain } from './types';
import { requestLnurlWithdraw } from '@/lib/lnurl/withdraw';
import { getInvoiceForLnurlPay } from '@/lib/lnurl/pay';
import { SpendFrom } from '@/globalTypes';

import { ShowToast } from '@/lib/contexts/useToast';
import { identifyBitcoinInput, parseBitcoinInput } from '@/lib/parse';
import { Satoshi } from '@/lib/types/units';
import { formatSatoshi } from '@/lib/units';
import { InputClassification, ParsedInput, ParsedInvoiceInput } from '@/lib/types/parse';
import { createNofferInvoice } from '@/lib/noffer';
import { nip19 } from 'nostr-tools';
import { getSourceInfo } from '../thunks/spendFrom';
import { appCreateAsyncThunk } from '../appCreateAsyncThunk';
import { App } from '@capacitor/app';





// Fetches all pub sources history
export const fetchAllSourcesHistory = (): ThunkAction<Promise<void>, State, undefined, AnyAction> => async (dispatch, getState) => {
	const nostrSpends = selectNostrSpends(getState());
	await Promise.all(nostrSpends.map(source => {
		return dispatch(fetchHistoryForSource(source.id))
	}))
}


// Fetches history for a single source
export const fetchHistoryForSource = appCreateAsyncThunk(
	"history/fetchHistoryForSource",
	async (
		sourceId: string,
		{ getState, dispatch }
	) => {
		const source = getState().spendSource.sources[sourceId];
		if (!source.pubSource) {
			throw new Error("Not a pub source");
		}


		const client = await getNostrClient(source.pasteField, source.keys);

		const newOps: UserOperation[] = [];
		let newCursor = getState().history.sources[sourceId]?.cursor || {};


		let needMore = true;

		while (needMore) {
			const res = await client.GetUserOperations(populateCursorRequest(newCursor));
			if (res.status !== "OK") {
				throw new Error(res.reason);
			}

			const { cursor, operations, needMoreData } = parseOperationsResponse(res, newCursor);
			newOps.push(...operations);
			newCursor = cursor;
			needMore = needMoreData;
		}

		const history = getState().history.sources[sourceId];
		const processedOperations = newOps.map(newOp => {
			const foundOperation = history?.data?.find(op => op.operationId === newOp.operationId);
			return userOperationToSourceOperation(newOp, sourceId, foundOperation);

		})

		if (processedOperations.length > 0) {
			dispatch(getSourceInfo(sourceId));
		}

		return { sourceId, newOps: processedOperations, newCursor }
	})


export const processNewIncomingOperation = appCreateAsyncThunk(
	"history/processNewIncomingOperation",
	(
		{ newOp, sourceId }: {
			newOp: UserOperation,
			sourceId: string
		},
		{ getState }
	) => {
		const source = getState().spendSource.sources[sourceId];
		if (!source) throw new Error("Source not found");

		// Check if the operation is already in the history
		const history = getState().history.sources[sourceId];
		const foundOperation = history?.data?.find(op => op.operationId === newOp.operationId);

		const operation = userOperationToSourceOperation(newOp, sourceId, foundOperation);
		return { operation, sourceId };
	}
)



export const listenforNewOperations = (): ThunkAction<Promise<void>, State, undefined, AnyAction> => async (dispatch, getState) => {
	const nostrSpends = selectNostrSpends(getState());
	await Promise.all(nostrSpends.map(source => {
		return dispatch(listenForSourceNewOperations(source.id))
	}))
}


const listenForSourceNewOperations = appCreateAsyncThunk(
	"history/listenForNewOperations",
	async (
		sourceId: string,
		{ getState, dispatch }
	) => {
		const source = getState().spendSource.sources[sourceId];
		if (!source) throw new Error("Source not found");
		const client = await getNostrClient(source.pasteField, source.keys);
		client.GetLiveUserOperations(newOp => {
			console.log({ newOp, source })
			if (newOp.status === "OK") {
				// receiving external on-chain txs causes two getLiveUserOperations procs
				// the history state takes care of this repetition,
				// but we have to deal with the toast not appearing twice here
				dispatch(getSourceInfo(sourceId));
				dispatch(processNewIncomingOperation({ newOp: newOp.operation, sourceId }))
			} else {
				console.error("Get live user operation error", newOp.reason)
			}
		})
	}
)



/*
 * The main function to send a payment. It works as follows:
 */
export const sendPaymentThunk = appCreateAsyncThunk(
	'paymentHistory/sendPayment',
	async (
		{
			sourceId,
			parsedInput,
			amount,
			note,
			satsPerVByte,
			showToast
		}: {
			sourceId: string,
			parsedInput: ParsedInput,
			amount: Satoshi,
			note?: string,
			satsPerVByte: number,
			showToast: ShowToast
		}, {
			dispatch, getState
		}) => {

		const selectedSource = getState().spendSource.sources[sourceId];
		if (!selectedSource) {
			throw new Error("Source not found");
		}
		const isPubSource = !!selectedSource.pubSource;
		const optimisticOperationId = `${Date.now()}-${Math.random().toString(36).substring(2, 7)}`; // Timestamp + random


		const payInvoice = async (parsedInvoice: ParsedInvoiceInput, optimisticOperationId: string, optimisticOperation: SourceOptimsiticInvoice) => {
			try {
				if (isPubSource) {
					const res = await (await getNostrClient(selectedSource.pasteField, selectedSource.keys)).PayInvoice({
						invoice: parsedInvoice.data,
						amount: 0,
					})
					if (res.status !== "OK") {
						throw new Error(res.reason);
					}

					App.exitApp();

					handlePaymentSuccess(dispatch, amount, selectedSource, optimisticOperationId, payInvoiceReponseToSourceOperation(res, optimisticOperation), showToast);


					dispatch(fetchHistoryForSource(sourceId));
				} else {
					// lnurl withdraw spend source
					await requestLnurlWithdraw({ invoice: parsedInvoice.data, amountSats: amount, lnurl: selectedSource.pasteField });

					const operation: SourceOperationInvoice = {
						sourceId: sourceId,
						amount: amount,
						operationId: `lnurl-withdraw-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
						type: "LNURL_WITHDRAW",
						invoice: parsedInvoice.data,
						invoiceMemo: parsedInvoice.memo,
						memo: optimisticOperation.memo,
						invoiceSource: optimisticOperation.invoiceSource,
						inbound: false,
						internal: false,
						paidAtUnix: Date.now(),
					}

					handlePaymentSuccess(dispatch, amount, selectedSource, optimisticOperationId, operation, showToast);
				}
			} catch (err) {
				handlePaymentError(err, dispatch, selectedSource.id, optimisticOperationId, showToast);
			}
		}

		switch (parsedInput.type) {
			case (InputClassification.LN_INVOICE): {
				const optimsticOperation: SourceOptimsiticInvoice = {
					optimistic: true,
					sourceId: sourceId,
					operationId: optimisticOperationId,
					amount: amount,
					paidAtUnix: Date.now(),

					type: "INVOICE",
					inbound: false,
					invoice: parsedInput.data,
					invoiceMemo: parsedInput.memo,
					memo: note,
				};
				dispatch(addOptimisticOperation({ sourceId: selectedSource.id, operation: optimsticOperation }));

				// We do not wait for the payInvoice to finish
				payInvoice(parsedInput, optimisticOperationId, optimsticOperation);
				return;
			}
			case InputClassification.LN_ADDRESS:
			case InputClassification.LNURL_PAY: {

				// Get the invoice
				let parsedInvoice: ParsedInvoiceInput;
				try {
					let invoice = "";
					if (parsedInput.noffer && isPubSource) {
						invoice = await createNofferInvoice(parsedInput.noffer, selectedSource.keys, amount);
					} else {
						const { pr } = await getInvoiceForLnurlPay({
							lnUrlOrAddress: parsedInput.data,
							amountSats: amount,
						});
						invoice = pr;
					}

					const classification = identifyBitcoinInput(invoice);
					if (classification !== InputClassification.LN_INVOICE) {
						throw new Error("Invalid invoice from Lnurl/Ln address");
					}
					parsedInvoice = await parseBitcoinInput(invoice, classification) as ParsedInvoiceInput;
				} catch (err) {
					showToast({
						message: `Could not get an invoice from ${parsedInput.type}`,
						color: "danger"
					})
					console.error(err);
					return;
				}


				const optimsticOperation: SourceOptimsiticInvoice = {
					optimistic: true,
					sourceId,
					operationId: optimisticOperationId,
					amount: amount,
					paidAtUnix: Date.now(),

					type: "INVOICE",
					inbound: false,
					invoice: parsedInvoice.data,
					invoiceMemo: parsedInvoice.memo,
					invoiceSource: parsedInput,
					memo: note,
				};
				dispatch(addOptimisticOperation({ sourceId: selectedSource.id, operation: optimsticOperation }));


				payInvoice(parsedInvoice, optimisticOperationId, optimsticOperation);
				return;
			}
			case InputClassification.NOFFER: {


				let parsedInvoice: ParsedInvoiceInput;
				if (parsedInput.priceType !== nip19.OfferPriceType.Spontaneous) {
					// For Fixed and Variable, we already have the invoice from the parsing step.
					parsedInvoice = parsedInput.invoiceData;
				} else {
					try {

						const invoice = await createNofferInvoice(parsedInput.noffer, selectedSource.keys, amount);

						const classification = identifyBitcoinInput(invoice);
						if (classification !== InputClassification.LN_INVOICE) {
							throw new Error("Invalid invoice from noffer");
						}
						parsedInvoice = await parseBitcoinInput(invoice, classification) as ParsedInvoiceInput;


					} catch (err) {
						showToast({
							message: "Payment failed",
							color: "danger"
						});
						console.error(err);
						return;
					}
				}

				const optimsticOperation: SourceOptimsiticInvoice = {
					optimistic: true,
					sourceId,
					operationId: optimisticOperationId,
					amount: amount,
					paidAtUnix: Date.now(),

					type: "INVOICE",
					inbound: false,
					invoice: parsedInvoice.data,
					invoiceMemo: parsedInvoice.memo,
					invoiceSource: parsedInput,
					memo: note,
				};
				dispatch(addOptimisticOperation({ sourceId: selectedSource.id, operation: optimsticOperation }));


				payInvoice(parsedInvoice, optimisticOperationId, optimsticOperation);
				return;
			}
			case InputClassification.BITCOIN_ADDRESS: {



				const optimisticOperation: SourceOptimsiticOnChain = {
					optimistic: true,
					sourceId,
					operationId: optimisticOperationId,
					amount: amount,
					paidAtUnix: Date.now(),

					status: "broadcasting",
					type: "ON-CHAIN",
					inbound: false,
					address: parsedInput.data,
					memo: note,
				};

				dispatch(addOptimisticOperation({ sourceId: selectedSource.id, operation: optimisticOperation }));

				(async () => {
					try {
						const payRes = await (await getNostrClient(selectedSource.pasteField, selectedSource.keys)).PayAddress({
							address: parsedInput.data,
							amoutSats: amount,
							satsPerVByte
						})

						if (payRes.status !== "OK") {
							throw new Error(payRes.reason);
						}

						const isInternal = payRes.network_fee === 0;
						let updatedOptimsticOperation: SourceOptimsiticOnChain;
						if (isInternal) {
							updatedOptimsticOperation = {
								...optimisticOperation,
								operationId: payRes.operation_id,
								internal: true,
								status: "success",
								serviceFee: payRes.service_fee,
							}
						} else {
							updatedOptimsticOperation = {
								...optimisticOperation,
								operationId: payRes.operation_id,
								internal: false,
								status: "confirming",
								networkFee: payRes.network_fee,
								serviceFee: payRes.service_fee,
								txHash: payRes.txId,
							}
						}
						dispatch(updateOptimsticOperation({ sourceId: selectedSource.id, operation: updatedOptimsticOperation, oldOperationId: optimisticOperationId }));
						dispatch(getSourceInfo(sourceId));

					} catch (err: any) {
						handlePaymentError(err, dispatch, selectedSource.id, optimisticOperationId, showToast);
					}
				})();
			}
		}
	});

const handlePaymentError = (
	err: any,
	dispatch: AppDispatch,
	sourceId: string,
	optimsticOpId: string,
	showToast: ShowToast
) => {
	console.error(err);
	dispatch(removeOptimisticOperation({ sourceId, operationId: optimsticOpId }));
	showToast({
		message: "Payment failed",
		color: "danger"
	});
}

const handlePaymentSuccess = (
	dispatch: AppDispatch,
	amount: Satoshi,
	selectedSource: SpendFrom,
	optimisticOpId: string,
	operation: SourceActualOperation,
	showToast: ShowToast
) => {
	dispatch(removeOptimisticOperation({ sourceId: selectedSource.id, operationId: optimisticOpId }));
	dispatch(addNewOperation({ sourceId: selectedSource.id, operation }));
	showToast({
		message: `Payment of ${formatSatoshi(amount)} sats sent`,
		color: "success",
	});
}
