import { AnyAction, ThunkAction } from '@reduxjs/toolkit';
import { emptyCursor, parseOperationsResponse, userOperationToSourceOperation, } from './helpers';
import { selectNostrPays, selectNostrSpends, State } from '../store';
import { getNostrClient } from '@/Api/nostr';
import type { UserOperation } from '../../Api/pub/autogenerated/ts/types';
import { getSourceInfo } from '../thunks/spendFrom';
import { appCreateAsyncThunk } from '../appCreateAsyncThunk';






// Fetches all pub sources history
export const fetchAllSourcesHistory = (): ThunkAction<Promise<void>, State, undefined, AnyAction> => async (dispatch, getState) => {
	const nostrSpends = selectNostrSpends(getState());
	await Promise.all(nostrSpends.map(source => {
		return dispatch(fetchHistoryForSource(source.id))
	}))
}


// Fetches history for a single source
export const fetchHistoryForSource = appCreateAsyncThunk(
	"history/fetchHistoryForSource",
	async (
		sourceId: string,
		{ getState, dispatch }
	) => {
		const source = getState().spendSource.sources[sourceId];
		if (!source.pubSource) {
			throw new Error("Not a pub source");
		}


		const client = await getNostrClient(source.pasteField, source.keys);

		const newOps: UserOperation[] = [];



		let needMore = true;
		let populatedCursor = getState().history?.sources[sourceId]?.cursor || emptyCursor();
		while (needMore) {
			const res = await client.GetUserOperations(populatedCursor);
			if (res.status !== "OK") {
				throw new Error(res.reason);
			}

			const { newCursor, operations, needMoreData } = parseOperationsResponse(res, populatedCursor);
			newOps.push(...operations);
			populatedCursor = newCursor;
			needMore = needMoreData;
		}

		const history = getState().history?.sources[sourceId];
		const processedOperations = newOps.map(newOp => {
			const foundOperation = history?.data?.find(op => op.operationId === newOp.operationId);
			return userOperationToSourceOperation(newOp, sourceId, foundOperation);

		})

		dispatch(getSourceInfo(sourceId));

		return { sourceId, newOps: processedOperations, newCursor: populatedCursor };
	})


export const processNewIncomingOperation = appCreateAsyncThunk(
	"history/processNewIncomingOperation",
	(
		{ newOp, sourceId }: {
			newOp: UserOperation,
			sourceId: string
		},
		{ getState }
	) => {
		const source = getState().spendSource.sources[sourceId];
		if (!source) throw new Error("Source not found");

		// Check if the operation is already in the history
		const history = getState().history?.sources[sourceId];
		const foundOperation = history?.data?.find(op => op.operationId === newOp.operationId);

		const operation = userOperationToSourceOperation(newOp, sourceId, foundOperation);
		return { operation, sourceId };
	}
)



export const listenforNewOperations = (): ThunkAction<Promise<void>, State, undefined, AnyAction> => async (dispatch, getState) => {
	const nostrSpends = selectNostrPays(getState());
	await Promise.all(nostrSpends.map(source => {
		return dispatch(listenForSourceNewOperations(source.id))
	}))
}


const listenForSourceNewOperations = appCreateAsyncThunk(
	"history/listenForNewOperations",
	async (
		sourceId: string,
		{ getState, dispatch }
	) => {
		const source = getState().spendSource.sources[sourceId];
		if (!source) throw new Error("Source not found");
		const client = await getNostrClient(source.pasteField, source.keys);
		client.GetLiveUserOperations(newOp => {
			if (newOp.status === "OK") {

				dispatch(getSourceInfo(sourceId));
				dispatch(processNewIncomingOperation({ newOp: newOp.operation, sourceId }))
			} else {
				console.error("Get live user operation error", newOp.reason)
			}
		})
	}
)


