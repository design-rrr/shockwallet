import { GetUserOperationsResponse, PayInvoiceResponse, UserOperation, UserOperationType } from "@/Api/pub/autogenerated/ts/types";
import { HistoryCursor, SourceActualOperation, SourceOperation, SourceOperationBase, SourceOperationInvoice, SourceOptimsiticInvoice } from "./types";
import { decodeInvoice } from "@/lib/invoice";
import { notifyReceivedOperation } from "@/lib/local-notifications";
import { Satoshi } from "@/lib/types/units";




// Helper function to convert a UserOperation to a SourceOperation
export const userOperationToSourceOperation = (op: UserOperation, sourceId: string, local?: SourceOperation): SourceActualOperation => {
	const incoming = transformUserOperationToSourceOperation(op, sourceId);
	if (local === undefined) {
		if (incoming.inbound) {
			notifyReceivedOperation(incoming.amount, incoming.operationId, incoming.type === "ON-CHAIN");
		}
		return incoming;
	}

	// Operations may have data that is truly local, like the local memo and the lnurl the
	// invoice was generated from in case of invoice operations. This function makes sure we merge
	// the incoming operation (UserOperation from pub) with the local one, so we don't lose that data.
	const operation: SourceActualOperation = {
		...incoming,
		memo: local.memo, // preserve local memo
		...(incoming.type === "INVOICE" && local.type === "INVOICE") ? { // preserve local invoice data
			invoiceMemo: local.invoiceMemo,
			invoiceSource: local.invoiceSource,
		} : {},
	}
	return operation;
}

export const payInvoiceReponseToSourceOperation = (resp: PayInvoiceResponse, optimisticOperation: SourceOptimsiticInvoice): SourceOperationInvoice => {

	const userOperation: UserOperation = {
		operationId: resp.operation_id,
		type: UserOperationType.OUTGOING_INVOICE,
		identifier: optimisticOperation.invoice,
		amount: resp.amount_paid as Satoshi,
		paidAtUnix: Date.now(),
		service_fee: resp.service_fee,
		network_fee: resp.network_fee,
		inbound: false,
		...(resp.preimage === "" // when preimage is empty, it's an internal payment
			? { internal: true }
			: {
				internal: false,
			}
		),
		confirmed: true,
		tx_hash: ""
	}

	return userOperationToSourceOperation(userOperation, optimisticOperation.sourceId, optimisticOperation) as SourceOperationInvoice;
}


const transformUserOperationToSourceOperation = (op: UserOperation, sourceId: string): SourceActualOperation => {
	const base: SourceOperationBase = {
		amount: op.amount as Satoshi,
		operationId: op.operationId,
		sourceId,
		paidAtUnix: op.paidAtUnix * 1000,
	}
	switch (op.type) {
		case UserOperationType.INCOMING_INVOICE:
		case UserOperationType.OUTGOING_INVOICE:
			return {
				...base,
				type: "INVOICE",
				invoice: op.identifier,
				inbound: op.type === UserOperationType.INCOMING_INVOICE,
				invoiceMemo: decodeInvoice(op.identifier)?.description,
				serviceFee: op.service_fee,

				...(op.internal
					? { internal: true }
					: {
						internal: false,
						networkFee: op.network_fee
					})
			}
		case UserOperationType.INCOMING_TX:
		case UserOperationType.OUTGOING_TX:
			return {
				...base,
				type: "ON-CHAIN",
				address: op.identifier,
				inbound: op.type === UserOperationType.INCOMING_TX,
				serviceFee: op.service_fee,
				...(op.internal
					? { internal: true }
					: {
						internal: false,
						networkFee: op.network_fee,
						txHash: op.tx_hash
					})
			}
		default:
			throw new Error("Unknown operation type")
	}
};





/* Pub source history fetching helpers for cursor management */
export const isAnyArrayLong = (arrays: any[][], max: number): boolean => {
	for (let i = 0; i < arrays.length; i++) {
		const array = arrays[i];
		if (array.length >= max) {
			return true
		}
	}
	return false
}

export const populateCursorRequest = (p: HistoryCursor) => {
	console.log("populateCursorRequest", p)
	const cursor = {
		latestIncomingInvoice: p.latestIncomingInvoice ? p.latestIncomingInvoice + 1 : 0,
		latestOutgoingInvoice: p.latestOutgoingInvoice ? p.latestOutgoingInvoice + 1 : 0,
		latestIncomingTx: p.latestIncomingTx ? p.latestIncomingTx + 1 : 0,
		latestOutgoingTx: p.latestOutgoingTx ? p.latestOutgoingTx + 1 : 0,
		latestIncomingUserToUserPayment: p.latestIncomingUserToUserPayment ? p.latestIncomingUserToUserPayment + 1 : 0,
		latestOutgoingUserToUserPayment: p.latestOutgoingUserToUserPayment ? p.latestOutgoingUserToUserPayment + 1 : 0,
		max_size: 10
	}

	return cursor
}

export const parseOperationsResponse = (r: GetUserOperationsResponse, c: HistoryCursor) => {
	console.log("parseOperationsResponse", "r", r, "c", c)
	const cursor: HistoryCursor = {
		latestIncomingInvoice: r.latestIncomingInvoiceOperations.toIndex || c.latestIncomingInvoice! + 1,
		latestOutgoingInvoice: r.latestOutgoingInvoiceOperations.toIndex || c.latestOutgoingInvoice! + 1,
		latestIncomingTx: r.latestIncomingTxOperations.toIndex || c.latestIncomingTx! + 1,
		latestOutgoingTx: r.latestOutgoingTxOperations.toIndex || c.latestOutgoingTx! + 1,
		latestIncomingUserToUserPayment: r.latestIncomingUserToUserPayemnts.toIndex || c.latestIncomingUserToUserPayment! + 1,
		latestOutgoingUserToUserPayment: r.latestOutgoingUserToUserPayemnts.toIndex || c.latestOutgoingUserToUserPayment! + 1,
		max_size: 10
	}

	const operations = [
		...r.latestIncomingInvoiceOperations.operations,
		...r.latestOutgoingInvoiceOperations.operations,
		...r.latestIncomingTxOperations.operations,
		...r.latestOutgoingTxOperations.operations,
		...r.latestIncomingUserToUserPayemnts.operations,
		...r.latestOutgoingUserToUserPayemnts.operations,
	]

	const needMoreData = isAnyArrayLong([
		r.latestIncomingInvoiceOperations.operations,
		r.latestOutgoingInvoiceOperations.operations,
		r.latestIncomingTxOperations.operations,
		r.latestOutgoingTxOperations.operations,
		r.latestIncomingUserToUserPayemnts.operations,
		r.latestOutgoingUserToUserPayemnts.operations,
	], 10)

	return { cursor, operations, needMoreData }
}
