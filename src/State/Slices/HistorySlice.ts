import { PayloadAction, createSlice } from '@reduxjs/toolkit';
import * as Types from '../../Api/pub/autogenerated/ts/types'
import { getDiffAsActionDispatch } from './dataMerge';
import { syncRedux } from '../store';
import loadInitialState, { MigrationFunction, applyMigrations, getStateAndVersion } from './migrations';
import { BackupAction } from '../types';
export const storageKey = "history"
export type SourceOperations = Record<string /*nprofile*/, Types.UserOperation[]>
type Cursor = Partial<Types.GetUserOperationsRequest>
interface History {
  operations: SourceOperations
  lnurlOperations: SourceOperations
  cursor: Cursor
  latestOperation: Partial<Types.UserOperation>
  operationsUpdateHook: number;
  optimisticOperations: (Types.UserOperation & { source: string, sourceLabel: string, optLabel?: string })[]
}

export const VERSION = 4;
export const migrations: Record<number, MigrationFunction<History>> = {
  // the missing latestOperation migration
  1: (state) => {
    const dummy: Record<string, any> = {
      operations: {},
      cursor: {},
      latestOperation: {},
      operationsUpdateHook: 0,
      optimisticOperations: []
    }
    const interfaceKeys = Object.keys(dummy);
    interfaceKeys.forEach(key => {
      if (state[key] === undefined) {
        state[key] = dummy[key]
      }
    })
    return state
  },
  2: (state: History) => {
    state.cursor = {};
    return state;
  },
  3: (state) => {
    const dummy: Record<string, any> = {
      operations: {},
      cursor: {},
      latestOperation: {},
      operationsUpdateHook: 0,
      optimisticOperations: []
    }
    const interfaceKeys = Object.keys(dummy);
    interfaceKeys.forEach(key => {
      if (state[key] === undefined) {
        state[key] = dummy[key]
      }
    })
    return state
  },
  4: (state) => {
    // move lnurl operations to their own key in the state
    Object.entries(state.operations).forEach(([key, operations]) => {
      state.lnurlOperations = {};
      state.latestLnurlOperation = {};

      if (key.toLowerCase().startsWith("lnurl")) {
        state.lnurlOperations[key] = operations;
        delete state.operations[key];
      }
    })
    return state;
  }
};
export const mergeLogic = (serialLocal: string, serialRemote: string): { data: string, actions: BackupAction[] } => {
  const local = getStateAndVersion(serialLocal);
  const remote = getStateAndVersion(serialRemote);

  const migratedRemote = applyMigrations(remote.state, remote.version, migrations);
  const migratedLocal = applyMigrations(local.state, local.version, migrations);

  const actions: BackupAction[] = [];

  const merged: History = {
    operations: migratedLocal.operations,
    lnurlOperations: getDiffAsActionDispatch(migratedRemote.lnurlOperations, migratedLocal.lnurlOperations, "history/setLatestLnurlOperation", actions),
    cursor: migratedLocal.cursor,
    latestOperation: migratedLocal.latestOperation,
    operationsUpdateHook: migratedLocal.operationsUpdateHook,
    optimisticOperations: migratedLocal.optimisticOperations
  }
  return {
    data: JSON.stringify({
      version: VERSION,
      data: merged
    }),
    actions
  }
}


const update = (value: History) => {
  const stateToSave = {
    version: VERSION,
    data: value,
  };
  localStorage.setItem(storageKey, JSON.stringify(stateToSave));
}

const initialState: History = loadInitialState(
  storageKey,
  JSON.stringify({ cursor: {}, operations: {}, latestOperation: {}, operationsUpdateHook: 0, optimisticOperations: [], lnurlOperations: {} }),
  migrations,
  update
);



const historySlice = createSlice({
  name: storageKey,
  initialState,
  reducers: {
    setSourceHistory: (state: History, action: PayloadAction<{ pub: string, operations: Types.UserOperation[], cursor: Cursor }>) => {
      const { pub, operations, cursor } = action.payload
      const stateOperations = state.operations[pub] || [];
      /* 
        Merge the two arrays, giving precedence to the dispatched operations
        to replace existing elements in state.operations.
        This is to update entries that were inserted with setLatestOperation
        where the status could be "Pending" and the fees inaccurate.
        This change is complimented by migration v2 that resets the cursor object
        to fix old operations from still being shown as "Pending"
      */
      const merged = [
        ...operations,
        ...stateOperations.filter(
          op1 => !operations.some(op2 => op2.operationId === op1.operationId)
        )
      ]
      state.operations[pub] = merged
      state.cursor = { ...cursor }
      update(state)
    },
    setLnurlSourceHistory: (state: History, action: PayloadAction<{ pub: string, operations: Types.UserOperation[] }>) => {
      const { pub, operations } = action.payload
      const stateOperations = state.operations[pub] || [];
      /* 
        Merge the two arrays, giving precedence to the dispatched operations
        to replace existing elements in state.operations.
        This is to update entries that were inserted with setLatestOperation
        where the status could be "Pending" and the fees inaccurate.
        This change is complimented by migration v2 that resets the cursor object
        to fix old operations from still being shown as "Pending"
      */
      const merged = [
        ...operations,
        ...stateOperations.filter(
          op1 => !operations.some(op2 => op2.operationId === op1.operationId)
        )
      ]
      state.lnurlOperations[pub] = merged.sort((a, b) => a.paidAtUnix - b.paidAtUnix); // sort because the order is critical in hash calculations in backups
      update(state)
    },
    setLatestOperation: (state, action: PayloadAction<{ pub: string, operation: Types.UserOperation }>) => {
      const { pub, operation } = action.payload
      state.latestOperation = { ...operation }
      if (!state.operations[pub]) {
        state.operations[pub] = [operation]
      } else {
        const existingIndex = state.operations[pub].findIndex(o => o.operationId === operation.operationId)
        if (existingIndex !== -1) {
          state.operations[pub][existingIndex] = { ...operation }
        } else {
          state.operations[pub].push(operation)
        }
      }
      update(state)
    },
    // only used in backups conflicts resolution
    clearLnurlOperations: (state) => {
      state.lnurlOperations = {};
      update(state)
    },
    setLatestLnurlOperation: (state, action: PayloadAction<{ pub: string, operation: Types.UserOperation }>) => {
      const { pub, operation } = action.payload
      state.latestOperation = { ...operation }
      if (!state.lnurlOperations[pub]) {
        state.lnurlOperations[pub] = [operation]
      } else {
        const existingIndex = state.lnurlOperations[pub].findIndex(o => o.operationId === operation.operationId)
        if (existingIndex !== -1) {
          state.lnurlOperations[pub][existingIndex] = { ...operation }
        } else {
          state.lnurlOperations[pub].push(operation)
        }
      }
      update(state)
    },
    updateOptimisticOperation: (state, action: PayloadAction<(Types.UserOperation & { source: string, sourceLabel: string, optLabel?: string })[]>) => {
      state.optimisticOperations = action.payload;
    },
    removeOptimisticOperation: (state, action: PayloadAction<string[]>) => {
      state.optimisticOperations = state.optimisticOperations.filter(op => !action.payload.includes(op.operationId));
    },
    procOperationsUpdateHook: (state) => {
      state.operationsUpdateHook = Math.random()
    }
  },
  extraReducers: (builder) => {
    builder.addCase(syncRedux, () => {
      return loadInitialState(
        storageKey,
        JSON.stringify({ cursor: {}, operations: {}, latestOperation: {}, operationsUpdateHook: 0, optimisticOperation: [], lnurlOperations: {} }),
        migrations,
        update
      );
    })
  }
});

export const { setSourceHistory, setLatestOperation, updateOptimisticOperation, removeOptimisticOperation, procOperationsUpdateHook, setLatestLnurlOperation, setLnurlSourceHistory } = historySlice.actions;
export default historySlice.reducer;
