import { PayloadAction, createSlice } from '@reduxjs/toolkit';
import * as Types from '../../Api/autogenerated/ts/types'
import { mergeArrayValues, mergeRecords } from './dataMerge';
export const storageKey = "history"
type SourceOperations = Record<string /*nprofile*/, Types.UserOperation[]>
type Cursor = Partial<Types.GetUserOperationsRequest>
interface History {
  operations?: SourceOperations
  cursor?: Cursor
  latestOperation?: Partial<Types.UserOperation>
  operationsUpdateHook?: number
}
export const mergeLogic = (serialLocal: string, serialRemote: string): string => {
  const local = JSON.parse(serialLocal) as History
  const remote = JSON.parse(serialRemote) as History
  const merged: History = {
    operations: mergeRecords<Types.UserOperation[]>(local.operations || {}, remote.operations || {}, (l, r) => mergeArrayValues(l, r, v => v.operationId)),
    cursor: local.cursor,
    latestOperation: local.latestOperation,
    operationsUpdateHook: local.operationsUpdateHook
  }
  return JSON.stringify(merged)
}

const historyLocal = localStorage.getItem(storageKey);

const update = (value: History) => {
  const save = JSON.stringify(value)
  localStorage.setItem(storageKey, save);
}

const initialState: History = JSON.parse(historyLocal ?? "{}");
// const ops: SourceOperations = {}
// Object.entries(initialState.operations || {}).forEach(([k, o]) => {
//   if (!Array.isArray(o)) {
//     ops[k] = Object.values(o) || []
//   }
// })
// initialState.operations = ops

const historySlice = createSlice({
  name: storageKey,
  initialState,
  reducers: {
    setSourceHistory: (state, action: PayloadAction<{ pub: string, operations: Types.UserOperation[], cursor: Cursor }>) => {
      const { pub, operations, cursor } = action.payload
      if (!state.operations) {
        state.operations = {}
      }
      state.operations[pub] = operations
      state.cursor = { ...cursor }
      state.operationsUpdateHook = Math.random()
      update(state)
    },
    setLatestOperation: (state, action: PayloadAction<{ pub: string, operation: Types.UserOperation }>) => {
      const { pub, operation } = action.payload
      state.latestOperation = { ...operation }
      if (!state.operations) {
        state.operations = {}
      }
      if (!state.operations[pub]) {
        state.operations[pub] = [operation]
      } else {
        const existingIndex = state.operations[pub].findIndex(o => o.operationId === operation.operationId)
        if (existingIndex !== -1) {
          state.operations[pub][existingIndex] = { ...operation }
        } else {
          state.operations[pub].push(operation)
        }
      }
      state.operationsUpdateHook = Math.random()
      update(state)
    },
  },
});

export const { setSourceHistory, setLatestOperation } = historySlice.actions;
export default historySlice.reducer;
