import { OfferDataType } from "@/Api/pub/autogenerated/ts/types";
import { Expression, Literal, Template, Variable } from "uri-template/dist/ast";

export const PAYER_DATA_KEY_RX = /^[A-Za-z][A-Za-z0-9_-]{0,31}$/; // 32 chars max
export const TOKEN_RX = /%\[([A-Za-z0-9_-]+)\]/g;
export const BUILT_INS = ["invoice", "amount"];



export function validateUrl(raw: string, sslOnly: boolean) {
	if (!raw.trim()) return { ok: true, https: true };
	const withScheme = /^https?:\/\//i.test(raw)
		? raw
		: `https://${raw}`;
	try {
		const u = new URL(withScheme);
		const isHttps = u.protocol === "https:";
		return { ok: sslOnly ? isHttps : isHttps || u.protocol === "http:", https: isHttps };
	} catch {
		return { ok: false, https: false };
	}
}








// Function to calculate character index at a given x position in an input element
// Uses a hidden div that mimics the input's font to measure where the cursor would be placed
export function charIndexAtX(
	input: HTMLInputElement,
	x: number,
	text: string
): number {
	const tmp = buildInputMimic(input);

	let low = 0;
	let high = text.length;
	while (low <= high) {
		const mid = (low + high) >> 1;
		tmp.textContent = text.slice(0, mid);
		const width = tmp.getBoundingClientRect().width;

		if (width < x) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
	}
	document.body.removeChild(tmp);
	return Math.min(low, text.length);
}


export function prefixWidthPx(
	input: HTMLInputElement,
	len: number,
	text: string
): number {
	const tmp = buildInputMimic(input);

	tmp.textContent = text.slice(0, len);
	document.body.appendChild(tmp);
	const width = tmp.getBoundingClientRect().width;
	document.body.removeChild(tmp);
	return width;
}


function buildInputMimic(
	input: HTMLInputElement,
): HTMLDivElement {
	const tmp = document.createElement("div");
	tmp.style.position = "absolute";
	tmp.style.whiteSpace = "pre";
	tmp.style.font = getComputedStyle(input).font;
	tmp.style.visibility = "hidden";
	tmp.style.pointerEvents = 'none';
	document.body.appendChild(tmp);
	return tmp;
}



export function keysToPayerData(keys: string[]): Record<string, OfferDataType> {
	return Object.fromEntries(keys.map(k => [k, OfferDataType.DATA_STRING]));
}



// Build expected_data from the raw url - unused but could be useful later
export function expectedFromUrl(url: string): Record<string, OfferDataType> {
	const tokens = Array.from(url.matchAll(TOKEN_RX)).map(m => m[1]);
	const unique = Array.from(new Set(tokens)).filter(t => !BUILT_INS.includes(t));
	const obj: Record<string, OfferDataType> = {};
	unique.forEach(t => (obj[t] = OfferDataType.DATA_STRING));
	return obj;
}




export function validateUrll(raw: string, sslOnly: boolean) {
	try {
		// Create sanitized version by removing templates
		const sanitized = raw.replace(/\{[^{}]*\}/g, "placeholder");
		const withScheme = /^https?:\/\//i.test(sanitized)
			? sanitized
			: `https://${sanitized}`;

		const u = new URL(withScheme);
		const isHttps = u.protocol === "https:";
		return {
			ok: sslOnly ? isHttps : isHttps || u.protocol === "http:",
			https: isHttps
		};
	} catch {
		return { ok: false, https: false };
	}
}

type URLComponent = {
	type: "scheme" | "host" | "path" | "query" | "fragment" | "template";
	start: number;
	end: number;
	value: string;
};

export function parseUrlComponents(url: string): URLComponent[] {
	const components: URLComponent[] = [];
	let lastIndex = 0;

	// 1. Extract templates first
	const templateRegex = /\{([^{}]+?)\}/g;
	let templateMatch;
	while ((templateMatch = templateRegex.exec(url)) !== null) {
		const [fullMatch, content] = templateMatch;
		const start = templateMatch.index;
		const end = start + fullMatch.length;

		// Add content before template
		if (start > lastIndex) {
			const before = url.slice(lastIndex, start);
			components.push(...parseNonTemplateParts(before, lastIndex));
		}

		// Add template
		components.push({
			type: "template",
			start,
			end,
			value: content
		});


		lastIndex = end;
	}

	// Add remaining non-template content
	if (lastIndex < url.length) {
		const remaining = url.slice(lastIndex);
		components.push(...parseNonTemplateParts(remaining, lastIndex));
	}

	return components;
}

interface ExprPos {
	node: Expression;
	start: number;
	end: number;
}
function stringify(ast: Template): string {
	return ast.parts
		.map(p =>
			p.type === "literal"
				? (p as Literal).value
				: `{${(p as Expression).operator}${(p as Expression).variables
					.map(v => v.name)
					.join(",")}}`,
		)
		.join("");
}
export function analyzeInsertionContext(
	index: number,
	token: string,
	components: URLComponent[],
	exprs: ExprPos[],
	ast: Template
): {
	modes: ("path" | "query")[];
	position: number;
} {
	const hit = exprs.find(e => index >= e.start && index <= e.end);
	if (hit && !hit.node.variables.some(v => v.name === token)) {

		hit.node.variables.push({ type: "variable", name: token } as Variable);
		return stringify(ast);
	}




	const hitComponent = components.find(c => index >= c.start && index <= c.end);
	const prevComponent = components.slice().reverse().find(c => c.end <= index);
	const nextComponent = components.find(c => c.start >= index);

	const hasQuery = components.some(c => c.type === "query") || exprs.some(e => e.node.operator === "?" || e.node.operator === "&");
	const hasFragment = components.some(c => c.type === "fragment");

	if (hitComponent) {
		switch (hitComponent.type) {
			// When hitting a query literal, we can insert only a & param after it
			case "query":
				return {
					modes: ["query"],
					position: hitComponent.end
				}

			case "fragment": {

			}


			case "host":
			case "scheme":
				return { type: "ambiguous", component: currentComponent, position: "after" };

			case "path":
				// If we're at the end of a path segment, allow path params
				if (currentComponent.value.endsWith("/")) {
					return { type: "path", component: currentComponent, position: "after" };
				}
				return { type: "ambiguous", component: currentComponent, position: "within" };
		}
	}
}
export function parseNonTemplateParts(str: string, globalOffset: number): URLComponent[] {
	const parts: URLComponent[] = [];
	let start = 0;

	// 2. Extract scheme if present
	const schemeMatch = str.match(/^([a-z]+:\/\/)/i);
	if (schemeMatch) {
		const [full] = schemeMatch;
		parts.push({
			type: "scheme",
			start: globalOffset + start,
			end: globalOffset + start + full.length,
			value: full
		});
		start += full.length;
	}

	// 3. Extract host (domain)
	const hostEnd = findHostEnd(str, start);
	if (hostEnd > start) {
		const hostValue = str.substring(start, hostEnd);
		parts.push({
			type: "host",
			start: globalOffset + start,
			end: globalOffset + hostEnd,
			value: hostValue
		});
		start = hostEnd;
	}

	// 4. Extract path, query, and fragment
	const pathStart = start;
	let queryStart = -1;
	let fragmentStart = -1;

	for (let i = start; i < str.length; i++) {
		if (str[i] === '?' && queryStart === -1) {
			// Path segment
			if (i > pathStart) {
				parts.push({
					type: "path",
					start: globalOffset + pathStart,
					end: globalOffset + i,
					value: str.substring(pathStart, i)
				});
			}
			queryStart = i;
		}
		else if (str[i] === '#' && fragmentStart === -1) {
			// Query segment
			if (queryStart !== -1 && i > queryStart) {
				parts.push({
					type: "query",
					start: globalOffset + queryStart,
					end: globalOffset + i,
					value: str.substring(queryStart, i)
				});
				queryStart = -1;
			}
			// Path segment (if no query)
			else if (i > pathStart) {
				parts.push({
					type: "path",
					start: globalOffset + pathStart,
					end: globalOffset + i,
					value: str.substring(pathStart, i)
				});
			}
			fragmentStart = i;
		}
	}

	// Add remaining segments
	if (queryStart !== -1) {
		// Query segment
		parts.push({
			type: "query",
			start: globalOffset + queryStart,
			end: globalOffset + str.length,
			value: str.substring(queryStart)
		});
	}
	else if (fragmentStart !== -1) {
		// Fragment segment
		parts.push({
			type: "fragment",
			start: globalOffset + fragmentStart,
			end: globalOffset + str.length,
			value: str.substring(fragmentStart)
		});
	}
	else if (pathStart < str.length) {
		// Path segment
		parts.push({
			type: "path",
			start: globalOffset + pathStart,
			end: globalOffset + str.length,
			value: str.substring(pathStart)
		});
	}

	return parts;
}


function findHostEnd(str: string, start: number): number {
	// Look for end of host (first '/' after scheme, or end of string)
	let pos = start;

	// Skip scheme if already processed
	if (str.startsWith("//", start)) {
		pos = start + 2;
	}

	// Find next path, query, or fragment delimiter
	for (; pos < str.length; pos++) {
		if (str[pos] === '/' || str[pos] === '?' || str[pos] === '#') {
			return pos;
		}
	}

	return str.length;
}

export function componentAt(
	index: number,
	components: URLComponent[],
) {
	return components.find(c => index >= c.start && index < c.end);
}


