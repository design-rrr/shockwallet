import { OfferDataType } from "@/Api/pub/autogenerated/ts/types";

export const PAYER_DATA_KEY_RX = /^[A-Za-z][A-Za-z0-9_-]{0,31}$/; // 32 chars max
export const TOKEN_RX = /%\[([A-Za-z0-9_-]+)\]/g;
export const BUILT_INS = ["invoice", "amount"];



export function validateUrl(raw: string, sslOnly: boolean) {
	if (!raw.trim()) return { ok: true, https: true };
	const withScheme = /^https?:\/\//i.test(raw)
		? raw
		: `https://${raw}`;
	try {
		const u = new URL(withScheme);
		const isHttps = u.protocol === "https:";
		return { ok: sslOnly ? isHttps : isHttps || u.protocol === "http:", https: isHttps };
	} catch {
		return { ok: false, https: false };
	}
};








// Function to calculate character index at a given x position in an input element
// Uses a hidden div that mimics the input's font to measure where the cursor would be placed
export function charIndexAtX(
	input: HTMLInputElement,
	x: number,
	text: string
): number {
	const tmp = buildInputMimic(input);

	let low = 0;
	let high = text.length;
	while (low <= high) {
		const mid = (low + high) >> 1;
		tmp.textContent = text.slice(0, mid);
		const width = tmp.getBoundingClientRect().width;

		if (width < x) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
	}
	document.body.removeChild(tmp);
	return Math.min(low, text.length);
}


export function prefixWidthPx(
	input: HTMLInputElement,
	len: number,
	text: string
): number {
	const tmp = buildInputMimic(input);

	tmp.textContent = text.slice(0, len);
	document.body.appendChild(tmp);
	const width = tmp.getBoundingClientRect().width;
	document.body.removeChild(tmp);
	return width;
}


function buildInputMimic(
	input: HTMLInputElement,
): HTMLDivElement {
	const tmp = document.createElement("div");
	tmp.style.position = "absolute";
	tmp.style.whiteSpace = "pre";
	tmp.style.font = getComputedStyle(input).font;
	tmp.style.visibility = "hidden";
	tmp.style.pointerEvents = 'none';
	document.body.appendChild(tmp);
	return tmp;
}



export function keysToPayerData(keys: string[]): Record<string, OfferDataType> {
	return Object.fromEntries(keys.map(k => [k, OfferDataType.DATA_STRING]));
}



// Build expected_data from the raw url - unused but could be useful later
export function expectedFromUrl(url: string): Record<string, OfferDataType> {
	const tokens = Array.from(url.matchAll(TOKEN_RX)).map(m => m[1]);
	const unique = Array.from(new Set(tokens)).filter(t => !BUILT_INS.includes(t));
	const obj: Record<string, OfferDataType> = {};
	unique.forEach(t => (obj[t] = OfferDataType.DATA_STRING));
	return obj;
}



