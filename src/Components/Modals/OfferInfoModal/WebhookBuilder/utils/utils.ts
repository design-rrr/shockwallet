import { OfferDataType } from "@/Api/pub/autogenerated/ts/types";
import { Expression, Literal, Template } from "uri-template/dist/ast";
import { InsertionMode, URLComponent } from "../types";


export const TOKEN_RX = /%\[([A-Za-z0-9_-]+)\]/g;
export const BUILT_INS = ["invoice", "amount"];










// Function to calculate character index at a given x position in an input element
// Uses a hidden div that mimics the input's font to measure character index
export function charIndexAtX(
	input: HTMLInputElement,
	x: number,
	text: string
): number {
	const tmp = buildInputMimic(input);

	let low = 0;
	let high = text.length;
	while (low <= high) {
		const mid = (low + high) >> 1;
		tmp.textContent = text.slice(0, mid);
		const width = tmp.getBoundingClientRect().width;

		if (width < x) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
	}
	document.body.removeChild(tmp);
	return Math.min(low, text.length);
}


export function prefixWidthPx(
	input: HTMLInputElement,
	len: number,
	text: string
): number {
	const tmp = buildInputMimic(input);

	tmp.textContent = text.slice(0, len);
	document.body.appendChild(tmp);
	const width = tmp.getBoundingClientRect().width;
	document.body.removeChild(tmp);
	return width;
}


function buildInputMimic(
	input: HTMLInputElement,
): HTMLDivElement {
	const tmp = document.createElement("div");
	tmp.style.position = "absolute";
	tmp.style.whiteSpace = "pre";
	tmp.style.font = getComputedStyle(input).font;
	tmp.style.visibility = "hidden";
	tmp.style.pointerEvents = 'none';
	document.body.appendChild(tmp);
	return tmp;
}



export function keysToPayerData(keys: string[]): Record<string, OfferDataType> {
	return Object.fromEntries(keys.map(k => [k, OfferDataType.DATA_STRING]));
}



// Build expected_data from the raw url - unused but could be useful later
export function expectedFromUrl(url: string): Record<string, OfferDataType> {
	const tokens = Array.from(url.matchAll(TOKEN_RX)).map(m => m[1]);
	const unique = Array.from(new Set(tokens)).filter(t => !BUILT_INS.includes(t));
	const obj: Record<string, OfferDataType> = {};
	unique.forEach(t => (obj[t] = OfferDataType.DATA_STRING));
	return obj;
}




export function stringify(ast: Template): string {
	return ast.parts
		.map(p =>
			p.type === "literal"
				? (p as Literal).value
				: `{${(p as Expression).operator}${(p as Expression).variables
					.map(v => v.name)
					.join(",")}}`,
		)
		.join("");
}



export function insertionHeuristics(
	index: number,
	token: string,
	components: URLComponent[],
): InsertionMode[] | null {

	const hit = components.find(c => index >= c.start && index < c.end);

	const prevComponent = components.slice().reverse().find(c => c.end <= index);
	const nextComponent = components.find(c => c.start >= index);

	const hasQuery = components.some(c => c.type === "query" || c.type);

	console.log({ hit })


	function basedOnPrev(): InsertionMode[] | null {
		console.log({ prevComponent })
		if (!prevComponent) {
			return [
				{
					type: "query",
					kind: "insert",
					position: 0
				},
				{
					type: "path",
					kind: "insert",
					position: 0
				}
			]
		}

		switch (prevComponent.type) {
			case "template":
				if (prevComponent.node.operator === "?" || prevComponent.node.operator === "&") {
					// If previous is a query operator, we can merge query param into it
					console.log("herererere", prevComponent.node.variables.some(v => {
						console.log(v.name, token)
						return v.name === token;
					}))
					if (prevComponent.node.variables.some(v => v.name === token)) {
						return null;
					}
					return [{
						type: "query",
						kind: "merge",
						node: prevComponent.node
					}];
				} else if (prevComponent.node.operator === "/" || prevComponent.node.operator === "") {
					// If previous is a path operator, we can either merge path into it, or insert a new query param after
					return [
						{
							type: "path",
							kind: "merge",
							node: prevComponent.node
						},
						{
							type: "query",
							kind: "insert",
							position: prevComponent.end
						}
					];
				} else {
					return null;
				}
			case "scheme":
				return null; // Cannot insert after scheme
			case "host":
			case "path":
				return [
					{
						type: "path",
						kind: "insert",
						position: prevComponent.end
					},
					{
						type: "query",
						kind: "insert",
						position: prevComponent.end
					}
				]
			case "query":
				return [{
					type: "query",
					kind: "insert",
					position: prevComponent.end
				}]
			case "fragment":
				return null;
			default:
				return null;
		}

	}


	if (!hit) {
		return basedOnPrev();
	}

	switch (hit.type) {

		case "template":
			if (!hit.node.variables.some(v => v.name === token)) {
				return [{
					type: "path",
					kind: "merge",
					node: hit.node
				}]
			} else {
				return null; // Token already exists in this template
			}
		// When hitting a query literal, we can insert only a & param after it
		case "query":
			return [{
				type: "query",
				kind: "insert",
				position: hit.end
			}];

		case "fragment": {
			return basedOnPrev();
		}
		case "scheme":
		case "host":
		case "path": {
			if (hit.type === "scheme") {
				const hostComp = components.find(c => c.type === "host");
				if (hostComp) {
					// Pretend caret is at the *start* of the host slice.
					// This mirrors user intent: they want to attach after the domain,
					// not inside "https://".
					return insertionHeuristics(hostComp.end, token, components);
				} else {
					return null;
				}
			}
			if (nextComponent) {
				switch (nextComponent.type) {
					case "template":
						if (nextComponent.node.operator === "/" || nextComponent.node.operator === "") {
							// If next is a path operator, we can insert a new path param after
							if (hasQuery) {
								return [{
									type: "path",
									kind: "insert",
									position: hit.end
								}]
							} else {
								return [{
									type: "path",
									kind: "insert",
									position: hit.end
								},
								{
									type: "query",
									kind: "insert",
									position: nextComponent.end
								}
								];
							}
						} else if (nextComponent.node.operator === "?") {
							// If next is a query operator, we can merge a query param into it
							return [{
								type: "query",
								kind: "merge",
								node: nextComponent.node
							}];
						} else {
							return null;
						}
					case "query":
						return [{
							type: "query",
							kind: "insert",
							position: nextComponent.end
						}]
					case "fragment":
						return [{
							type: "query",
							kind: "insert",
							position: hit.end,
						},
						{
							type: "path",
							kind: "insert",
							position: hit.end
						}
						]

					case "path":
						return [{
							type: "path",
							kind: "insert",
							position: hit.end
						}]
					default:
						return null;
				}
			} else {
				return [{
					type: "path",
					kind: "insert",
					position: hit.end
				},
				{
					type: "query",
					kind: "insert",
					position: hit.end
				}]
			}
		}

	}

}
export function parseNonTemplateParts(str: string, globalOffset: number): URLComponent[] {
	const parts: URLComponent[] = [];
	let start = 0;

	// 2. Extract scheme if present
	const schemeMatch = str.match(/^([a-z]+:\/\/)/i);
	if (schemeMatch) {
		const [full] = schemeMatch;
		parts.push({
			type: "scheme",
			start: globalOffset + start,
			end: globalOffset + start + full.length,
			value: full
		});
		start += full.length;
	}

	// 3. Extract host (domain)
	const hostEnd = findHostEnd(str, start);
	if (hostEnd > start) {
		const hostValue = str.substring(start, hostEnd);
		parts.push({
			type: "host",
			start: globalOffset + start,
			end: globalOffset + hostEnd,
			value: hostValue
		});
		start = hostEnd;
	}

	// 4. Extract path, query, and fragment
	const pathStart = start;
	let queryStart = -1;
	let fragmentStart = -1;

	for (let i = start; i < str.length; i++) {
		if (str[i] === '?' && queryStart === -1) {
			// Path segment
			if (i > pathStart) {
				parts.push({
					type: "path",
					start: globalOffset + pathStart,
					end: globalOffset + i,
					value: str.substring(pathStart, i)
				});
			}
			queryStart = i;
		}
		else if (str[i] === '#' && fragmentStart === -1) {
			// Query segment
			if (queryStart !== -1 && i > queryStart) {
				parts.push({
					type: "query",
					start: globalOffset + queryStart,
					end: globalOffset + i,
					value: str.substring(queryStart, i)
				});
				queryStart = -1;
			}
			// Path segment (if no query)
			else if (i > pathStart) {
				parts.push({
					type: "path",
					start: globalOffset + pathStart,
					end: globalOffset + i,
					value: str.substring(pathStart, i)
				});
			}
			fragmentStart = i;
		}
	}

	// Add remaining segments
	if (queryStart !== -1) {
		// Query segment
		parts.push({
			type: "query",
			start: globalOffset + queryStart,
			end: globalOffset + str.length,
			value: str.substring(queryStart)
		});
	}
	else if (fragmentStart !== -1) {
		// Fragment segment
		parts.push({
			type: "fragment",
			start: globalOffset + fragmentStart,
			end: globalOffset + str.length,
			value: str.substring(fragmentStart)
		});
	}
	else if (pathStart < str.length) {
		// Path segment
		parts.push({
			type: "path",
			start: globalOffset + pathStart,
			end: globalOffset + str.length,
			value: str.substring(pathStart)
		});
	}

	return parts;
}


function findHostEnd(str: string, start: number): number {
	// Look for end of host (first '/' after scheme, or end of string)
	let pos = start;

	// Skip scheme if already processed
	if (str.startsWith("//", start)) {
		pos = start + 2;
	}

	// Find next path, query, or fragment delimiter
	for (; pos < str.length; pos++) {
		if (str[pos] === '/' || str[pos] === '?' || str[pos] === '#') {
			return pos;
		}
	}

	return str.length;
}

